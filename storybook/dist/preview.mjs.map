{"version":3,"sources":["../node_modules/ts-dedent/src/index.ts","../src/addons/actions/decorator.ts","../src/addons/actions/loader.ts","../src/preview.ts"],"names":["dedent","templ","values","_i","strings","indentLengths","arr","str","matches","match","_a","_b","pattern_1","string","value","i","endentations","endentation","indentedValue","esm_default","ACTION_ATTRIBUTE","proxifyEvent","e","elementProxy","target","key","obj","setupActionListeners","StoryFn","context","args","root","arg","name","el","eventArgs","isAction","actionLoader","fetchStoryHtml","url","path","params","storyContext","fetchUrl","decorators","loaders","parameters"],"mappings":"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","sourcesContent":["export function dedent(\n  templ: TemplateStringsArray | string,\n  ...values: unknown[]\n): string {\n  let strings = Array.from(typeof templ === 'string' ? [templ] : templ);\n\n  // 1. Remove trailing whitespace.\n  strings[strings.length - 1] = strings[strings.length - 1].replace(\n    /\\r?\\n([\\t ]*)$/,\n    '',\n  );\n\n  // 2. Find all line breaks to determine the highest common indentation level.\n  const indentLengths = strings.reduce((arr, str) => {\n    const matches = str.match(/\\n([\\t ]+|(?!\\s).)/g);\n    if (matches) {\n      return arr.concat(\n        matches.map((match) => match.match(/[\\t ]/g)?.length ?? 0),\n      );\n    }\n    return arr;\n  }, <number[]>[]);\n\n  // 3. Remove the common indentation from all strings.\n  if (indentLengths.length) {\n    const pattern = new RegExp(`\\n[\\t ]{${Math.min(...indentLengths)}}`, 'g');\n\n    strings = strings.map((str) => str.replace(pattern, '\\n'));\n  }\n\n  // 4. Remove leading whitespace.\n  strings[0] = strings[0].replace(/^\\r?\\n/, '');\n\n  // 5. Perform interpolation.\n  let string = strings[0];\n\n  values.forEach((value, i) => {\n    // 5.1 Read current indentation level\n    const endentations = string.match(/(?:^|\\n)( *)$/)\n    const endentation = endentations ? endentations[1] : ''\n    let indentedValue = value\n    // 5.2 Add indentation to values with multiline strings\n    if (typeof value === 'string' && value.includes('\\n')) {\n      indentedValue = String(value)\n        .split('\\n')\n        .map((str, i) => {\n          return i === 0 ? str : `${endentation}${str}`\n        })\n        .join('\\n');\n    }\n\n    string += indentedValue + strings[i + 1];\n  });\n\n  return string;\n}\n\nexport default dedent;\n","import { DecoratorFunction } from '@storybook/types';\nimport { ServerRenderer } from '@storybook/server';\nimport dedent from 'ts-dedent';\n\n\nconst ACTION_ATTRIBUTE = 'data-storybook-action';\nconst proxifyEvent = <T extends Event>(e: T) => {\n    if (e.currentTarget !== null && Object.hasOwn(e.currentTarget, '__component')) {\n        // Special handling for Live Components:\n        // creates a proxy wrapper to omit the __component property that could\n        // make actions calls when its properties are listed\n        const elementProxy = new Proxy(e.currentTarget, {\n            ownKeys(target: Element): ArrayLike<string | symbol> {\n                return Object.keys(target).filter((key) => key !== '__component');\n            },\n        });\n        return new Proxy(e, {\n            get(obj, key) {\n                if (key === 'currentTarget') {\n                    return elementProxy;\n                }\n                return Reflect.get(obj, key);\n            },\n        });\n    }\n\n    return e;\n};\n\nexport const setupActionListeners: DecoratorFunction<ServerRenderer> = (StoryFn, context) => {\n    const { args } = context;\n    const root = document.getElementById('storybook-root');\n\n    // Configure action listeners once story has been rendered\n    document.addEventListener('DOMContentLoaded', () => {\n        if (null === root) {\n            return;\n        }\n        Object.entries(args)\n            .filter(([, arg]) => typeof arg === 'function' && arg._sfActionId !== undefined)\n            .forEach(([name, arg]) => {\n                const el = root.querySelector(`[${ACTION_ATTRIBUTE}='${arg._sfActionId}']`)\n                if (null !== el) {\n                    el.addEventListener(name, (...eventArgs) => {\n                        arg(...eventArgs.map(proxifyEvent))\n                    });\n                } else {\n                    console.warn(dedent`\n                        Action arg \"${name} is not bound to any DOM element.\"\n                    `);\n                }\n            });\n    }, {once: true});\n\n    return StoryFn(context);\n};\n","import { LoaderFunction } from '@storybook/types';\n\nconst isAction = (arg: any): boolean => {\n    return (typeof arg === 'function') && (\n        ('_isMockFunction' in arg && arg._isMockFunction)\n        || ('isAction' in arg && arg.isAction)\n    );\n}\nexport const actionLoader: LoaderFunction = (context) => {\n    const {args} = context;\n\n    Object.entries(args).filter(([, value]) => isAction(value)\n    ).forEach(([name, value]) => {\n        value._sfActionId = name;\n        if (value._isMockFunction) {\n            value.mockReset();\n        }\n    });\n};\n","import { Args } from '@storybook/types';\nimport { StoryContext} from '@storybook/server';\nimport { setupActionListeners } from './addons/actions/decorator';\nimport { actionLoader } from './addons/actions/loader';\n\n\n/**\n * Copy/pasted from storybook/renderers/server/src/render.ts.\n *\n * So we can wrap the output in decorators.\n */\nconst fetchStoryHtml = async (url: string, path: string, params: any, storyContext: StoryContext<Args>) => {\n    const fetchUrl = new URL(`${url}/${path}`);\n\n    for (const name in params) {\n        if (params[name]._sfActionId !== undefined) {\n            params[name] = params[name]._sfActionId;\n        }\n    }\n    fetchUrl.search = new URLSearchParams({ ...storyContext.globals, ...params }).toString();\n\n    const response = await fetch(fetchUrl);\n\n    return response.text();\n};\n\n\nexport const decorators = [\n    setupActionListeners,\n];\n\nexport const loaders = [actionLoader];\n\nexport const parameters = {\n    server: {\n        url: `${window.location.origin}/_storybook/render`,\n        fetchStoryHtml: fetchStoryHtml\n    }\n}\n"]}