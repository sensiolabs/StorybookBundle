{"version":3,"sources":["../../node_modules/webpack-virtual-modules/src/virtual-stats.ts","../../node_modules/webpack-virtual-modules/src/index.ts","../../node_modules/is-extglob/index.js","../../node_modules/is-glob/index.js","../../node_modules/balanced-match/index.js","../../node_modules/brace-expansion/index.js","../../node_modules/fast-xml-parser/src/util.js","../../node_modules/fast-xml-parser/src/validator.js","../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js","../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js","../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js","../../node_modules/strnum/strnum.js","../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js","../../node_modules/fast-xml-parser/src/xmlparser/node2json.js","../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js","../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js","../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js","../../node_modules/fast-xml-parser/src/fxp.js","../../src/server/lib/symfony.ts","../../node_modules/ts-dedent/src/index.ts","../../src/server/framework-preset.ts","../../src/server/lib/preview-compiler-plugin.ts","../../src/server/lib/injectPreviewHtml.ts","../../src/server/lib/dev-preview-compiler-plugin.ts","../../src/server/lib/computeAdditionalWatchPaths.ts","../../node_modules/glob/node_modules/minimatch/src/index.ts","../../node_modules/glob/node_modules/minimatch/src/assert-valid-pattern.ts","../../node_modules/glob/node_modules/minimatch/src/brace-expressions.ts","../../node_modules/glob/node_modules/minimatch/src/unescape.ts","../../node_modules/glob/node_modules/minimatch/src/ast.ts","../../node_modules/glob/node_modules/minimatch/src/escape.ts","../../node_modules/lru-cache/src/index.ts","../../node_modules/path-scurry/src/index.ts","../../node_modules/minipass/src/index.ts","../../node_modules/glob/src/glob.ts","../../node_modules/glob/src/pattern.ts","../../node_modules/glob/src/ignore.ts","../../node_modules/glob/src/processor.ts","../../node_modules/glob/src/walker.ts","../../node_modules/glob/src/has-magic.ts","../../node_modules/glob/src/index.ts","../../src/server/lib/twig-loader-plugin.ts","../../src/server/lib/extractComponentsFromTemplate.ts","../../src/server/lib/TwigComponentResolver.ts"],"names":["constants_1","__importDefault","VirtualStats","config","key","property","exports","path_1","virtual_stats_1","inode","ALL","STATIC","DYNAMIC","checkActivation","instance","getModulePath","filePath","compiler","createWebpackData","result","backendOrStorage","curLevelIdx","curLevel","getData","storage","setData","valueFactory","value","getStatStorage","fileSystem","getFileStorage","getReadDirBackend","VirtualModulesPlugin","modules","filter","shouldGetStaticModules","shouldGetDynamicModules","finalInputFileSystem","_a","virtualFiles","_b","dynamicModules","contents","len","time","date","stats","modulePath","finalWatchFileSystem","fileWatchers","fileWatcher","afterEnvironmentHook","originalPurge","file","data","statStorage","fileStorage","readDirStorage","segments","count","minCount","dir","dirStats","dirData","filename","files","afterResolversHook","version","watchRunHook","watcher","callback","fts","mtime","module","require_is_extglob","__commonJSMin","str","match","require_is_glob","isExtglob","chars","strictCheck","index","pipeIndex","closeSquareIndex","closeCurlyIndex","closeParenIndex","backSlashIndex","open","close","n","relaxedCheck","options","check","require_balanced_match","balanced","a","b","maybeMatch","r","range","reg","m","begs","beg","left","right","ai","bi","i","require_brace_expansion","expandTop","escSlash","escOpen","escClose","escComma","escPeriod","numeric","escapeBraces","unescapeBraces","parseCommaParts","parts","pre","body","post","p","postParts","expand","embrace","isPadded","el","lte","y","gte","isTop","expansions","k","expansion","isNumericSequence","isAlphaSequence","isSequence","isOptions","N","x","width","incr","test","reverse","pad","c","need","z","j","require_util","nameStartChar","nameChar","nameRegexp","regexName","getAllMatches","string","regex","matches","allmatches","isName","v","obj","target","arrayMode","keys","require_validator","util","defaultOptions","xmlData","tags","tagFound","reachedRoot","readPI","tagStartPos","readCommentAndCDATA","closingTag","tagName","validateTagName","msg","getErrorObject","getLineNumberForPosition","readAttributeStr","attrStr","attrStrStart","isValid","validateAttributeString","otg","openPos","afterAmp","validateAmpersand","isWhiteSpace","t","char","start","tagname","angleBracketsCount","doubleQuote","singleQuote","startChar","tagClosed","validAttrStrRegxp","attrNames","getPositionFromMatch","attrName","validateAttrName","validateNumberAmpersand","re","code","message","lineNumber","lines","require_OptionsBuilder","val","jPath","attrs","buildOptions","require_xmlNode","XmlNode","node","require_DocTypeReader","readDocType","entities","hasBody","comment","exp","isEntity","readEntityExp","validateEntityName","isElement","isAttlist","isNotation","isComment","entityName","name","require_strnum","hexRegex","numRegex","consider","toNumber","trimmedStr","sign","leadingZeros","numTrimmedByZeros","trimZeros","eNotation","num","numStr","require_OrderedObjParser","xmlNode","OrderedObjParser","_","addExternalEntities","parseXml","parseTextData","resolveNameSpace","buildAttributesMap","isItStopNode","replaceEntitiesValue","readStopNodeData","saveTextToParentTag","addChild","externalEntities","entKeys","ent","dontTrim","hasAttributes","isLeafNode","escapeEntities","newval","parseValue","prefix","attrsRegx","oldVal","aName","newVal","attrCollection","xmlObj","currentNode","textData","closeIndex","findClosingIndex","colonIndex","lastTagName","propIndex","tagData","readTagExp","childNode","endIndex","tagExp","rawTagName","attrExpPresent","lastTag","tagContent","entity","stopNodes","currentTagName","allNodesExp","stopNodePath","stopNodeExp","tagExpWithClosingIndex","closingChar","attrBoundary","ch","errMsg","closingIndex","removeNSPrefix","separatorIndex","startIndex","openTagCount","shouldParse","require_node2json","prettify","compress","arr","text","compressedObj","tagObj","propName","newJpath","isLeaf","isLeafTag","assignAttributes","attrMap","jpath","atrrName","textNodeName","propCount","require_XMLParser","validator","XMLParser","validationOption","orderedObjParser","orderedResult","require_orderedJs2Xml","EOL","toXml","jArray","indentation","arrToStr","xmlStr","isPreviousElementTag","newJPath","tagText","isStopNode","attStr","attr_to_str","tempInd","piTextNodeName","newIdentation","tagStart","tagValue","attr","attrVal","textValue","require_json2xml","buildFromOrderedJs","Builder","isAttribute","processTextOrObjNode","indentate","jObj","level","arrLen","listTagVal","item","Ks","L","object","tagEndExp","piClosingChar","closeTag","require_fxp","XMLBuilder","exec","dedent","templ","values","_i","strings","indentLengths","pattern_1","endentations","endentation","indentedValue","esm_default","prepareSymfonyCommand","command","inputs","finalOptions","part","execSymfonyCommand","finalCommand","resolve","reject","error","stdout","stderr","runSymfonyCommand","runSymfonyCommandJson","getKernelProjectDir","getBundleConfig","getTwigComponentConfiguration","join","createUnplugin","HtmlWebpackPlugin","logger","JSDOM","injectPreviewHtml","previewHtml","targetHtml","previewDom","previewHead","previewBody","PLUGIN_NAME","PreviewCompilerPlugin","compilation","params","err","import_webpack_virtual_modules","import_is_glob","import_brace_expansion","assertValidPattern","pattern","posixClasses","braceEscape","regexpEscape","rangesToString","ranges","parseClass","glob","position","pos","negs","sawStart","uflag","escaping","negate","endPos","rangeStart","WHILE","cls","unip","u","neg","sranges","snegs","unescape","windowsPathsNoEscape","types","isExtglobType","startNoTraversal","startNoDot","addPatternStart","justDots","reSpecials","regExpEscape","qmark","star","starNoEmpty","AST","_AST","#root","#hasMagic","#uflag","#parts","#parent","#parentIndex","#negs","#filledNegs","#options","#toString","#emptyExt","type","parent","#fillNegs","pp","ret","pl","#parseAST","ast","opt","inBrace","braceStart","braceNeg","acc","ext","hasMagic","flags","allowDot","dot","noEmpty","src","#parseGlob","aps","needNoTrav","needNoDot","end","repeated","#partsToRegExp","s","bodyDotAllowed","final","_hasMagic","needUflag","consumed","magic","escape","minimatch","Minimatch","starDotExtRE","starDotExtTest","f","starDotExtTestDot","starDotExtTestNocase","starDotExtTestNocaseDot","starDotStarRE","starDotStarTest","starDotStarTestDot","dotStarRE","dotStarTest","starRE","starTest","starTestDot","qmarksRE","qmarksTestNocase","$0","noext","qmarksTestNoExt","qmarksTestNocaseDot","qmarksTestNoExtDot","qmarksTestDot","qmarksTest","defaultPlatform","path","sep","GLOBSTAR","twoStarDot","twoStarNoDot","defaults","def","orig","list","braceExpand","makeRe","mm","globMagic","args","rawGlobParts","set","__","isUNC","isDrive","ss","globParts","optimizationLevel","gs","prev","didSomething","dd","gss","next","p2","other","splin","matched","emptyGSMatch","which","negateOffset","partial","fileDrive","fileUNC","patternDrive","patternUNC","fdi","pdi","fd","pd","fi","pi","fl","fr","pr","swallowee","hit","fastTest","twoStar","ff","perf","warned","PROCESS","emitWarning","fn","AC","AS","warnACPolyfill","reason","printACPolyfillWarning","shouldWarn","TYPE","isPosInt","getUintArray","max","ZeroArray","size","Stack","_Stack","#constructing","HeapCls","LRUCache","_LRUCache","#max","#maxSize","#dispose","#disposeAfter","#fetchMethod","#size","#calculatedSize","#keyMap","#keyList","#valList","#next","#prev","#head","#tail","#free","#disposed","#sizes","#starts","#ttls","#hasDispose","#hasFetchMethod","#hasDisposeAfter","#isBackgroundFetch","context","#backgroundFetch","#moveToTail","#indexes","#rindexes","#isStale","ttl","ttlResolution","ttlAutopurge","updateAgeOnGet","updateAgeOnHas","allowStale","dispose","disposeAfter","noDisposeOnSet","noUpdateTTL","maxSize","maxEntrySize","sizeCalculation","fetchMethod","noDeleteOnFetchRejection","noDeleteOnStaleGet","allowStaleOnFetchRejection","allowStaleOnFetchAbort","ignoreFetchAbort","UintArray","#initializeSizeTracking","#initializeTTLTracking","ttls","starts","#setItemTTL","#updateItemAge","#statusTTL","status","cachedNow","getNow","age","sizes","#removeItemSize","#requireSize","#addItemSize","#evict","_s","_st","_k","_v","#isValidIndex","getOptions","thisp","deleted","entry","remain","setOptions","oldValue","dt","task","free","head","hasOptions","peekOptions","ac","signal","fetchOpts","cb","updateCache","aborted","ignoreAbort","fetchFail","bf","eb","er","allowStaleAborted","noDelete","pcall","res","rej","fmp","fetchOptions","forceRefresh","stale","isStale","staleVal","fetching","#connect","ni","posix","win32","fileURLToPath","actualFS","lstatSync","readdirCB","readdirSync","readlinkSync","rps","lstat","readdir","readlink","realpath","EventEmitter","Stream","StringDecoder","proc","isStream","Minipass","isReadable","isWritable","EOF","MAYBE_EMIT_END","EMITTED_END","EMITTING_END","EMITTED_ERROR","CLOSED","READ","FLUSH","FLUSHCHUNK","ENCODING","DECODER","FLOWING","PAUSED","RESUME","BUFFER","PIPES","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","DESTROYED","ERROR","EMITDATA","EMITEND","EMITEND2","ASYNC","ABORT","ABORTED","SIGNAL","DATALISTENERS","DISCARDED","defer","nodefer","isEndish","ev","isArrayBufferLike","isArrayBufferView","Pipe","dest","opts","_er","PipeProxyErrors","isObjectModeOptions","o","isEncodingOptions","_enc","_om","chunk","encoding","noDrain","ended","handler","h","buf","stopped","stop","onerr","ondata","onend","ondestroy","wc","realpathSync","defaultFS","fsFromOption","fsOption","uncDriveRegexp","uncToDrive","rootPath","eitherSep","UNKNOWN","IFIFO","IFCHR","IFDIR","IFBLK","IFREG","IFLNK","IFSOCK","IFMT","IFMT_UNKNOWN","READDIR_CALLED","LSTAT_CALLED","ENOTDIR","ENOENT","ENOREADLINK","ENOREALPATH","ENOCHILD","TYPEMASK","entToType","normalizeCache","normalize","normalizeNocaseCache","normalizeNocase","ResolveCache","ChildrenCache","setAsCwd","PathBase","#fs","#dev","#mode","#nlink","#uid","#gid","#rdev","#blksize","#ino","#blocks","#atimeMs","#mtimeMs","#ctimeMs","#birthtimeMs","#atime","#mtime","#ctime","#birthtime","#matchName","#depth","#fullpath","#fullpathPosix","#relative","#relativePosix","#type","#children","#linkTarget","#realpath","root","roots","nocase","children","dirParts","#resolveParts","cached","pathPart","fullpath","pchild","pv","fp","pfpp","fpp","ifmt","read","linkTarget","#readlinkFail","#readdirSuccess","#markENOENT","#markChildrenENOENT","#markENOREALPATH","#markENOTDIR","#readdirFail","#lstatFail","ter","#readdirAddChild","e","#readdirMaybePromoteChild","#readdirAddNewChild","child","#readdirPromoteChild","#applyStat","st","atime","atimeMs","birthtime","birthtimeMs","blksize","blocks","ctime","ctimeMs","dev","gid","ino","mode","mtimeMs","nlink","rdev","uid","#onReaddirCB","#readdirCBInFlight","#callOnReaddirCB","cbs","allowZalgo","entries","#asyncReaddirInFlight","dirs","walkFilter","rp","oldCwd","changed","PathWin32","_PathWin32","compare","PathScurryWin32","PathPosix","_PathPosix","_rootPath","PathScurryBase","#resolveCache","#resolvePosixCache","cwd","pathImpl","childrenCacheSize","fs","cwdPath","split","joinSep","abs","sawFirst","l","paths","withFileTypes","follow","results","walk","queue","processing","process","paused","onReaddir","didRealpaths","promises","sync","PathScurryPosix","_dir","PathScurryDarwin","Path","PathScurry","isPatternList","isGlobList","gl","Pattern","_Pattern","#patternList","#globList","#index","#platform","#rest","#globString","#isDrive","#isUNC","#isAbsolute","#followGlobstar","patternList","globList","platform","p0","p1","p3","prest","g0","g1","g2","g3","grest","g","Ignore","ignored","nobrace","noglobstar","mmopts","ign","parsed","absolute","fullpaths","relative","relatives","HasWalkedCache","_HasWalkedCache","store","MatchRecord","ifDir","current","SubWalks","subs","Processor","_Processor","hasWalkedCache","patterns","processingSet","rest","rrest","tp","ep","makeIgnore","ignore","GlobUtil","#onResume","#ignore","#sep","#ignored","#childrenIgnored","rpc","needStat","mark","rel","processor","tasks","childrenCached","GlobWalker","GlobStream","Glob","Scurry","nocaseMagicOnly","mmo","mms","matchSet","globStreamSync","globStream","globSync","glob_","globIterateSync","globIterate","streamSync","stream","iterateSync","iterate","computeAdditionalWatchPaths","baseDir","watchPath","isGlob","DevPreviewCompilerPlugin","projectDir","additionalWatchPaths","id","resolvedWatchPaths","import_fast_xml_parser","extractComponentsFromTemplate","source","reservedNames","tagRe","functionRe","lookupComponents","names","documentObj","TwigComponentResolver","stripDirectory","namespace","trimmed","nameParts","lookupPaths","__require","crypto","TwigLoaderPlugin","twigComponentConfiguration","resolver","imports","getBuildOptions","symfonyOptions","twigComponentsConfig","componentNamespaces","namePrefix","templateDirectory","anonymousNamespace","runtimeDir","webpack","framework","frameworkOptions","base"],"mappings":"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","sourcesContent":["/**\n * Used to cache a stats object for the virtual file.\n * Extracted from the `mock-fs` package.\n *\n * @author Tim Schaub http://tschaub.net/\n * @author `webpack-virtual-modules` Contributors\n * @link https://github.com/tschaub/mock-fs/blob/master/lib/binding.js\n * @link https://github.com/tschaub/mock-fs/blob/master/license.md\n */\nimport constants from 'constants';\n\nexport class VirtualStats {\n  /**\n   * Create a new stats object.\n   *\n   * @param config Stats properties.\n   */\n  public constructor(config) {\n    for (const key in config) {\n      if (!Object.prototype.hasOwnProperty.call(config, key)) {\n        continue;\n      }\n      this[key] = config[key];\n    }\n  }\n\n  /**\n   * Check if mode indicates property.\n   */\n  private _checkModeProperty(property): boolean {\n    return ((this as any).mode & constants.S_IFMT) === property;\n  }\n\n  public isDirectory(): boolean {\n    return this._checkModeProperty(constants.S_IFDIR);\n  }\n\n  public isFile(): boolean {\n    return this._checkModeProperty(constants.S_IFREG);\n  }\n\n  public isBlockDevice(): boolean {\n    return this._checkModeProperty(constants.S_IFBLK);\n  }\n\n  public isCharacterDevice(): boolean {\n    return this._checkModeProperty(constants.S_IFCHR);\n  }\n\n  public isSymbolicLink(): boolean {\n    return this._checkModeProperty(constants.S_IFLNK);\n  }\n\n  public isFIFO(): boolean {\n    return this._checkModeProperty(constants.S_IFIFO);\n  }\n\n  public isSocket(): boolean {\n    return this._checkModeProperty(constants.S_IFSOCK);\n  }\n}\n","import path from 'path';\nimport { VirtualStats } from './virtual-stats';\nimport type { Compiler } from 'webpack';\n\nlet inode = 45000000;\nconst ALL = 'all';\nconst STATIC = 'static';\nconst DYNAMIC = 'dynamic';\n\ntype AvailableModules = typeof ALL | typeof STATIC | typeof DYNAMIC;\n\nfunction checkActivation(instance) {\n  if (!instance._compiler) {\n    throw new Error('You must use this plugin only after creating webpack instance!');\n  }\n}\n\nfunction getModulePath(filePath, compiler) {\n  return path.isAbsolute(filePath) ? filePath : path.join(compiler.context, filePath);\n}\n\nfunction createWebpackData(result) {\n  return (backendOrStorage) => {\n    // In Webpack v5, this variable is a \"Backend\", and has the data stored in a field\n    // _data. In V4, the `_` prefix isn't present.\n    if (backendOrStorage._data) {\n      const curLevelIdx = backendOrStorage._currentLevel;\n      const curLevel = backendOrStorage._levels[curLevelIdx];\n      return {\n        result,\n        level: curLevel,\n      };\n    }\n    // Webpack 4\n    return [null, result];\n  };\n}\n\nfunction getData(storage, key) {\n  // Webpack 5\n  if (storage._data instanceof Map) {\n    return storage._data.get(key);\n  } else if (storage._data) {\n    return storage.data[key];\n  } else if (storage.data instanceof Map) {\n    // Webpack v4\n    return storage.data.get(key);\n  } else {\n    return storage.data[key];\n  }\n}\n\nfunction setData(backendOrStorage, key, valueFactory) {\n  const value = valueFactory(backendOrStorage);\n\n  // Webpack v5\n  if (backendOrStorage._data instanceof Map) {\n    backendOrStorage._data.set(key, value);\n  } else if (backendOrStorage._data) {\n    backendOrStorage.data[key] = value;\n  } else if (backendOrStorage.data instanceof Map) {\n    // Webpack 4\n    backendOrStorage.data.set(key, value);\n  } else {\n    backendOrStorage.data[key] = value;\n  }\n}\n\nfunction getStatStorage(fileSystem) {\n  if (fileSystem._statStorage) {\n    // Webpack v4\n    return fileSystem._statStorage;\n  } else if (fileSystem._statBackend) {\n    // webpack v5\n    return fileSystem._statBackend;\n  } else {\n    // Unknown version?\n    throw new Error(\"Couldn't find a stat storage\");\n  }\n}\n\nfunction getFileStorage(fileSystem) {\n  if (fileSystem._readFileStorage) {\n    // Webpack v4\n    return fileSystem._readFileStorage;\n  } else if (fileSystem._readFileBackend) {\n    // Webpack v5\n    return fileSystem._readFileBackend;\n  } else {\n    throw new Error(\"Couldn't find a readFileStorage\");\n  }\n}\n\nfunction getReadDirBackend(fileSystem) {\n  if (fileSystem._readdirBackend) {\n    return fileSystem._readdirBackend;\n  } else if (fileSystem._readdirStorage) {\n    return fileSystem._readdirStorage;\n  } else {\n    throw new Error(\"Couldn't find a readDirStorage from Webpack Internals\");\n  }\n}\n\nclass VirtualModulesPlugin {\n  private _staticModules: Record<string, string> | null;\n  private _compiler: Compiler | null = null;\n  private _watcher: any = null;\n\n  public constructor(modules?: Record<string, string>) {\n    this._staticModules = modules || null;\n  }\n\n  public getModuleList(filter: AvailableModules = ALL) {\n    let modules = {};\n    const shouldGetStaticModules = filter === ALL || filter === STATIC;\n    const shouldGetDynamicModules = filter === ALL || filter === DYNAMIC;\n\n    if (shouldGetStaticModules) {\n      // Get static modules\n      modules = {\n        ...modules,\n        ...this._staticModules,\n      };\n    }\n\n    if (shouldGetDynamicModules) {\n      // Get dynamic modules\n      const finalInputFileSystem: any = this._compiler?.inputFileSystem;\n      const virtualFiles = finalInputFileSystem?._virtualFiles ?? {};\n\n      const dynamicModules: Record<string, string> = {};\n      Object.keys(virtualFiles).forEach((key: string) => {\n        dynamicModules[key] = virtualFiles[key].contents;\n      });\n\n      modules = {\n        ...modules,\n        ...dynamicModules,\n      };\n    }\n\n    return modules;\n  }\n\n  public writeModule(filePath: string, contents: string): void {\n    if (!this._compiler) {\n      throw new Error(`Plugin has not been initialized`);\n    }\n\n    checkActivation(this);\n\n    const len = contents ? contents.length : 0;\n    const time = Date.now();\n    const date = new Date(time);\n\n    const stats = new VirtualStats({\n      dev: 8675309,\n      nlink: 0,\n      uid: 1000,\n      gid: 1000,\n      rdev: 0,\n      blksize: 4096,\n      ino: inode++,\n      mode: 33188,\n      size: len,\n      blocks: Math.floor(len / 4096),\n      atime: date,\n      mtime: date,\n      ctime: date,\n      birthtime: date,\n    });\n    const modulePath = getModulePath(filePath, this._compiler);\n\n    if (process.env.WVM_DEBUG)\n      // eslint-disable-next-line no-console\n      console.log(this._compiler.name, 'Write virtual module:', modulePath, contents);\n\n    // When using the WatchIgnorePlugin (https://github.com/webpack/webpack/blob/52184b897f40c75560b3630e43ca642fcac7e2cf/lib/WatchIgnorePlugin.js),\n    // the original watchFileSystem is stored in `wfs`. The following \"unwraps\" the ignoring\n    // wrappers, giving us access to the \"real\" watchFileSystem.\n    let finalWatchFileSystem = this._watcher && this._watcher.watchFileSystem;\n\n    while (finalWatchFileSystem && finalWatchFileSystem.wfs) {\n      finalWatchFileSystem = finalWatchFileSystem.wfs;\n    }\n\n    let finalInputFileSystem: any = this._compiler.inputFileSystem;\n    while (finalInputFileSystem && finalInputFileSystem._inputFileSystem) {\n      finalInputFileSystem = finalInputFileSystem._inputFileSystem;\n    }\n\n    finalInputFileSystem._writeVirtualFile(modulePath, stats, contents);\n    if (\n      finalWatchFileSystem &&\n      finalWatchFileSystem.watcher &&\n      (finalWatchFileSystem.watcher.fileWatchers.size || finalWatchFileSystem.watcher.fileWatchers.length)\n    ) {\n      const fileWatchers =\n        finalWatchFileSystem.watcher.fileWatchers instanceof Map\n          ? Array.from(finalWatchFileSystem.watcher.fileWatchers.values())\n          : finalWatchFileSystem.watcher.fileWatchers;\n      for (let fileWatcher of fileWatchers) {\n        if ('watcher' in fileWatcher) {\n          fileWatcher = fileWatcher.watcher;\n        }\n        if (fileWatcher.path === modulePath) {\n          if (process.env.DEBUG)\n            // eslint-disable-next-line no-console\n            console.log(this._compiler.name, 'Emit file change:', modulePath, time);\n          delete fileWatcher.directoryWatcher._cachedTimeInfoEntries;\n          fileWatcher.emit('change', time, null);\n        }\n      }\n    }\n  }\n\n  public apply(compiler: Compiler) {\n    this._compiler = compiler;\n\n    const afterEnvironmentHook = () => {\n      let finalInputFileSystem: any = compiler.inputFileSystem;\n      while (finalInputFileSystem && finalInputFileSystem._inputFileSystem) {\n        finalInputFileSystem = finalInputFileSystem._inputFileSystem;\n      }\n\n      if (!finalInputFileSystem._writeVirtualFile) {\n        const originalPurge = finalInputFileSystem.purge;\n\n        finalInputFileSystem.purge = () => {\n          originalPurge.apply(finalInputFileSystem, []);\n          if (finalInputFileSystem._virtualFiles) {\n            Object.keys(finalInputFileSystem._virtualFiles).forEach((file) => {\n              const data = finalInputFileSystem._virtualFiles[file];\n              finalInputFileSystem._writeVirtualFile(file, data.stats, data.contents);\n            });\n          }\n        };\n\n        finalInputFileSystem._writeVirtualFile = (file, stats, contents) => {\n          const statStorage = getStatStorage(finalInputFileSystem);\n          const fileStorage = getFileStorage(finalInputFileSystem);\n          const readDirStorage = getReadDirBackend(finalInputFileSystem);\n          finalInputFileSystem._virtualFiles = finalInputFileSystem._virtualFiles || {};\n          finalInputFileSystem._virtualFiles[file] = { stats: stats, contents: contents };\n          setData(statStorage, file, createWebpackData(stats));\n          setData(fileStorage, file, createWebpackData(contents));\n          const segments = file.split(/[\\\\/]/);\n          let count = segments.length - 1;\n          const minCount = segments[0] ? 1 : 0;\n          while (count > minCount) {\n            const dir = segments.slice(0, count).join(path.sep) || path.sep;\n            try {\n              finalInputFileSystem.readdirSync(dir);\n            } catch (e) {\n              const time = Date.now();\n              const dirStats = new VirtualStats({\n                dev: 8675309,\n                nlink: 0,\n                uid: 1000,\n                gid: 1000,\n                rdev: 0,\n                blksize: 4096,\n                ino: inode++,\n                mode: 16877,\n                size: stats.size,\n                blocks: Math.floor(stats.size / 4096),\n                atime: time,\n                mtime: time,\n                ctime: time,\n                birthtime: time,\n              });\n\n              setData(readDirStorage, dir, createWebpackData([]));\n              setData(statStorage, dir, createWebpackData(dirStats));\n            }\n            let dirData = getData(getReadDirBackend(finalInputFileSystem), dir);\n            // Webpack v4 returns an array, webpack v5 returns an object\n            dirData = dirData[1] || dirData.result;\n            const filename = segments[count];\n            if (dirData.indexOf(filename) < 0) {\n              const files = dirData.concat([filename]).sort();\n              setData(getReadDirBackend(finalInputFileSystem), dir, createWebpackData(files));\n            } else {\n              break;\n            }\n            count--;\n          }\n        };\n      }\n    };\n    const afterResolversHook = () => {\n      if (this._staticModules) {\n        for (const [filePath, contents] of Object.entries(this._staticModules)) {\n          this.writeModule(filePath, contents);\n        }\n        this._staticModules = null;\n      }\n    };\n\n    // The webpack property is not exposed in webpack v4\n    const version = typeof (compiler as any).webpack === 'undefined' ? 4 : 5;\n\n    const watchRunHook = (watcher, callback) => {\n      this._watcher = watcher.compiler || watcher;\n      const virtualFiles = (compiler as any).inputFileSystem._virtualFiles;\n      const fts = compiler.fileTimestamps as any;\n\n      if (virtualFiles && fts && typeof fts.set === 'function') {\n        Object.keys(virtualFiles).forEach((file) => {\n          const mtime = +virtualFiles[file].stats.mtime;\n          // fts is\n          // Map<string, number> in webpack 4\n          // Map<string, { safeTime: number; timestamp: number; }> in webpack 5\n          fts.set(\n            file,\n            version === 4\n              ? mtime\n              : {\n                  safeTime: mtime,\n                  timestamp: mtime,\n                }\n          );\n        });\n      }\n      callback();\n    };\n\n    if (compiler.hooks) {\n      compiler.hooks.afterEnvironment.tap('VirtualModulesPlugin', afterEnvironmentHook);\n      compiler.hooks.afterResolvers.tap('VirtualModulesPlugin', afterResolversHook);\n      compiler.hooks.watchRun.tapAsync('VirtualModulesPlugin', watchRunHook);\n    } else {\n      (compiler as any).plugin('after-environment', afterEnvironmentHook);\n      (compiler as any).plugin('after-resolvers', afterResolversHook);\n      (compiler as any).plugin('watch-run', watchRunHook);\n    }\n  }\n}\n\nexport = VirtualModulesPlugin;\n","/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n","/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = require('is-extglob');\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar relaxedCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nmodule.exports = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var check = strictCheck;\n\n  // optionally relax check\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n\n  return check(str);\n};\n","'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n","var balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  if (/\\$$/.test(m.pre)) {    \n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre+ '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function(p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length)\n      var incr = n.length == 3\n        ? Math.abs(numeric(n[2]))\n        : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\')\n            c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0)\n                c = '-' + z + c.slice(1);\n              else\n                c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion)\n          expansions.push(expansion);\n      }\n    }\n  }\n\n  return expansions;\n}\n\n","'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n","'use strict';\n\nconst util = require('./util');\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n  unpairedTags: []\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  \n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else if(options.unpairedTags.indexOf(tagName) !== -1){\n            //don't push into stack\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }else{\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n              return getErrorObject('InvalidXml', \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n            }\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if ( isWhiteSpace(xmlData[i])) {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\nfunction isWhiteSpace(char){\n  return char === ' ' || char === '\\t' || char === '\\n'  || char === '\\r';\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' is without value.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n","\nconst defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: '@_',\n    attributesGroupName: false,\n    textNodeName: '#text',\n    ignoreAttributes: true,\n    removeNSPrefix: false, // remove NS from tag name or attribute name if true\n    allowBooleanAttributes: false, //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true, //Trim string values of tag and attributes\n    cdataPropName: false,\n    numberParseOptions: {\n      hex: true,\n      leadingZeros: true,\n      eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n      return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n      return val;\n    },\n    stopNodes: [], //nested tags will not be parsed even for errors\n    alwaysCreateTextNode: false,\n    isArray: () => false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs){\n      return tagName\n    },\n    // skipEmptyListItem: false\n};\n   \nconst buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\n\nexports.buildOptions = buildOptions;\nexports.defaultOptions = defaultOptions;","'use strict';\n\nclass XmlNode{\n  constructor(tagname) {\n    this.tagname = tagname;\n    this.child = []; //nested tags, text, cdata, comments in order\n    this[\":@\"] = {}; //attributes map\n  }\n  add(key,val){\n    // this.child.push( {name : key, val: val, isCdata: isCdata });\n    if(key === \"__proto__\") key = \"#__proto__\";\n    this.child.push( {[key]: val });\n  }\n  addChild(node) {\n    if(node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n    if(node[\":@\"] && Object.keys(node[\":@\"]).length > 0){\n      this.child.push( { [node.tagname]: node.child, [\":@\"]: node[\":@\"] });\n    }else{\n      this.child.push( { [node.tagname]: node.child });\n    }\n  };\n};\n\n\nmodule.exports = XmlNode;","const util = require('../util');\n\n//TODO: handle comments\nfunction readDocType(xmlData, i){\n    \n    const entities = {};\n    if( xmlData[i + 3] === 'O' &&\n         xmlData[i + 4] === 'C' &&\n         xmlData[i + 5] === 'T' &&\n         xmlData[i + 6] === 'Y' &&\n         xmlData[i + 7] === 'P' &&\n         xmlData[i + 8] === 'E')\n    {    \n        i = i+9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(;i<xmlData.length;i++){\n            if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                if( hasBody && isEntity(xmlData, i)){\n                    i += 7; \n                    [entityName, val,i] = readEntityExp(xmlData,i+1);\n                    if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                        entities[ validateEntityName(entityName) ] = {\n                            regx : RegExp( `&${entityName};`,\"g\"),\n                            val: val\n                        };\n                }\n                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported\n                else if( isComment)                         comment = true;\n                else                                        throw new Error(\"Invalid DOCTYPE\");\n\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === '>') { //Read tag content\n                if(comment){\n                    if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                }else{\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                  break;\n                }\n            }else if( xmlData[i] === '['){\n                hasBody = true;\n            }else{\n                exp += xmlData[i];\n            }\n        }\n        if(angleBracketsCount !== 0){\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    }else{\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {entities, i};\n}\n\nfunction readEntityExp(xmlData,i){\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    \n    //read EntityName\n    let entityName = \"\";\n    for (; i < xmlData.length && (xmlData[i] !== \"'\" && xmlData[i] !== '\"' ); i++) {\n        // if(xmlData[i] === \" \") continue;\n        // else \n        entityName += xmlData[i];\n    }\n    entityName = entityName.trim();\n    if(entityName.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");\n\n    //read Entity Value\n    const startChar = xmlData[i++];\n    let val = \"\"\n    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {\n        val += xmlData[i];\n    }\n    return [entityName, val, i];\n}\n\nfunction isComment(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === '-' &&\n    xmlData[i+3] === '-') return true\n    return false\n}\nfunction isEntity(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'N' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'I' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'Y') return true\n    return false\n}\nfunction isElement(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'L' &&\n    xmlData[i+4] === 'E' &&\n    xmlData[i+5] === 'M' &&\n    xmlData[i+6] === 'E' &&\n    xmlData[i+7] === 'N' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\n\nfunction isAttlist(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'A' &&\n    xmlData[i+3] === 'T' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'L' &&\n    xmlData[i+6] === 'I' &&\n    xmlData[i+7] === 'S' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\nfunction isNotation(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'N' &&\n    xmlData[i+3] === 'O' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'A' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'I' &&\n    xmlData[i+8] === 'O' &&\n    xmlData[i+9] === 'N') return true\n    return false\n}\n\nfunction validateEntityName(name){\n    if (util.isName(name))\n\treturn name;\n    else\n        throw new Error(`Invalid entity name ${name}`);\n}\n\nmodule.exports = readDocType;\n","const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;\n// const octRegex = /0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n    Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n    Number.parseFloat = window.parseFloat;\n}\n\n  \nconst consider = {\n    hex :  true,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    // const options = Object.assign({}, consider);\n    // if(opt.leadingZeros === false){\n    //     options.leadingZeros = false;\n    // }else if(opt.hex === false){\n    //     options.hex = false;\n    // }\n\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    // if(trimmedStr === \"0.0\") return 0;\n    // else if(trimmedStr === \"+0.0\") return 0;\n    // else if(trimmedStr === \"-0.0\") return -0;\n\n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return Number.parseInt(trimmedStr, 16);\n    // } else if (options.parseOct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            const eNotation = match[4] || match[6];\n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(eNotation){ //given number has enotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    // const decimalPart = match[5].substr(1);\n                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf(\".\"));\n\n                    \n                    // const p = numStr.indexOf(\".\");\n                    // const givenIntPart = numStr.substr(0,p);\n                    // const givenDecPart = numStr.substr(p+1);\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    // if(numTrimmedByZeros === numStr){\n                    //     if(options.leadingZeros) return num;\n                    //     else return str;\n                    // }else return str;\n                    if(numTrimmedByZeros === numStr) return num;\n                    else if(sign+numTrimmedByZeros === numStr) return num;\n                    else return str;\n                }\n\n                if(trimmedStr === numStr) return num;\n                else if(trimmedStr === sign+numStr) return num;\n                // else{\n                //     //number with +/- sign\n                //     trimmedStr.test(/[-+][0-9]);\n\n                // }\n                return str;\n            }\n            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;\n            \n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\nmodule.exports = toNumber\n","'use strict';\n///@ts-check\n\nconst util = require('../util');\nconst xmlNode = require('./xmlNode');\nconst readDocType = require(\"./DocTypeReader\");\nconst toNumber = require(\"strnum\");\n\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nclass OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"\" },\n      \"num_dec\": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },\n      \"num_hex\": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 16)) },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if(aName === \"__proto__\") aName  = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\")+1);\n        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0\n        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)\n          this.tagsNodeStack.pop();\n        }else{\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n\n        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n          this.addChild(currentNode, childNode, jPath)\n\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n        if(val == undefined) val = \"\";\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);\n        let tagName= result.tagName;\n        const rawTagName = result.rawTagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\n            i = result.closeIndex;\n          }\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          this.addChild(currentNode, childNode, jPath)\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            \n            if(this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nfunction addChild(currentNode, childNode, jPath){\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"])\n  if(result === false){\n  }else if(typeof result === \"string\"){\n    childNode.tagname = result\n    currentNode.addChild(childNode);\n  }else{\n    currentNode.addChild(childNode);\n  }\n}\n\nconst replaceEntitiesValue = function(val){\n\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\nfunction isItStopNode(stopNodes, jPath, currentTagName){\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\n  }\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substring(0, separatorIndex);\n    tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n  }\n\n  const rawTagName = tagName;\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n    rawTagName: rawTagName,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\"){ \n      if (xmlData[i+1] === \"/\") {//close tag\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n          if(closeTagName === tagName){\n            openTagCount--;\n            if (openTagCount === 0) {\n              return {\n                tagContent: xmlData.substring(startIndex, i),\n                i : closeIndex\n              }\n            }\n          }\n          i=closeIndex;\n        } else if(xmlData[i+1] === '?') { \n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 2) === '![') { \n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n          i=closeIndex;\n        } else {\n          const tagData = readTagExp(xmlData, i, '>')\n\n          if (tagData) {\n            const openTagName = tagData && tagData.tagName;\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n              openTagCount++;\n            }\n            i=tagData.closeIndex;\n          }\n        }\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n\nmodule.exports = OrderedObjParser;\n","'use strict';\n\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */\nfunction prettify(node, options){\n  return compress( node, options);\n}\n\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */\nfunction compress(arr, options, jPath){\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property = propName(tagObj);\n    let newJpath = \"\";\n    if(jPath === undefined) newJpath = property;\n    else newJpath = jPath + \".\" + property;\n\n    if(property === options.textNodeName){\n      if(text === undefined) text = tagObj[property];\n      else text += \"\" + tagObj[property];\n    }else if(property === undefined){\n      continue;\n    }else if(tagObj[property]){\n      \n      let val = compress(tagObj[property], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n\n      if(tagObj[\":@\"]){\n        assignAttributes( val, tagObj[\":@\"], newJpath, options);\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\n        val = val[options.textNodeName];\n      }else if(Object.keys(val).length === 0){\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n        else val = \"\";\n      }\n\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n        if(!Array.isArray(compressedObj[property])) {\n            compressedObj[property] = [ compressedObj[property] ];\n        }\n        compressedObj[property].push(val);\n      }else{\n        //TODO: if a node is not an array, then check if it should be an array\n        //also determine if it is a leaf node\n        if (options.isArray(property, newJpath, isLeaf )) {\n          compressedObj[property] = [val];\n        }else{\n          compressedObj[property] = val;\n        }\n      }\n    }\n    \n  }\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n  if(typeof text === \"string\"){\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\n\nfunction propName(obj){\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if(key !== \":@\") return key;\n  }\n}\n\nfunction assignAttributes(obj, attrMap, jpath, options){\n  if (attrMap) {\n    const keys = Object.keys(attrMap);\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [ attrMap[atrrName] ];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\n\nfunction isLeafTag(obj, options){\n  const { textNodeName } = options;\n  const propCount = Object.keys(obj).length;\n  \n  if (propCount === 0) {\n    return true;\n  }\n\n  if (\n    propCount === 1 &&\n    (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)\n  ) {\n    return true;\n  }\n\n  return false;\n}\nexports.prettify = prettify;\n","const { buildOptions} = require(\"./OptionsBuilder\");\nconst OrderedObjParser = require(\"./OrderedObjParser\");\nconst { prettify} = require(\"./node2json\");\nconst validator = require('../validator');\n\nclass XMLParser{\n    \n    constructor(options){\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n        \n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */\n    parse(xmlData,validationOption){\n        if(typeof xmlData === \"string\"){\n        }else if( xmlData.toString){\n            xmlData = xmlData.toString();\n        }else{\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\")\n        }\n        if( validationOption){\n            if(validationOption === true) validationOption = {}; //validate with default options\n            \n            const result = validator.validate(xmlData, validationOption);\n            if (result !== true) {\n              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\n            }\n          }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return prettify(orderedResult, this.options);\n    }\n\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */\n    addEntity(key, value){\n        if(value.indexOf(\"&\") !== -1){\n            throw new Error(\"Entity value can't have '&'\")\n        }else if(key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1){\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\")\n        }else if(value === \"&\"){\n            throw new Error(\"An entity with value '&' is not permitted\");\n        }else{\n            this.externalEntities[key] = value;\n        }\n    }\n}\n\nmodule.exports = XMLParser;","const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if(tagName === undefined) continue;\n\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if(!obj.hasOwnProperty(key)) continue;\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            if(!attrMap.hasOwnProperty(attr)) continue;\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n","'use strict';\n//parse Empty Node as self closing node\nconst buildFromOrderedJs = require('./orderedJs2Xml');\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attributesGroupName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataPropName: false,\n  format: false,\n  indentBy: '  ',\n  suppressEmptyNode: false,\n  suppressUnpairedNode: true,\n  suppressBooleanAttributes: true,\n  tagValueProcessor: function(key, a) {\n    return a;\n  },\n  attributeValueProcessor: function(attrName, a) {\n    return a;\n  },\n  preserveOrder: false,\n  commentPropName: false,\n  unpairedTags: [],\n  entities: [\n    { regex: new RegExp(\"&\", \"g\"), val: \"&amp;\" },//it must be on top\n    { regex: new RegExp(\">\", \"g\"), val: \"&gt;\" },\n    { regex: new RegExp(\"<\", \"g\"), val: \"&lt;\" },\n    { regex: new RegExp(\"\\'\", \"g\"), val: \"&apos;\" },\n    { regex: new RegExp(\"\\\"\", \"g\"), val: \"&quot;\" }\n  ],\n  processEntities: true,\n  stopNodes: [],\n  // transformTagName: false,\n  // transformAttributeName: false,\n  oneListGroup: false\n};\n\nfunction Builder(options) {\n  this.options = Object.assign({}, defaultOptions, options);\n  if (this.options.ignoreAttributes || this.options.attributesGroupName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n\n  this.processTextOrObjNode = processTextOrObjNode\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n}\n\nBuilder.prototype.build = function(jObj) {\n  if(this.options.preserveOrder){\n    return buildFromOrderedJs(jObj, this.options);\n  }else {\n    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){\n      jObj = {\n        [this.options.arrayNodeName] : jObj\n      }\n    }\n    return this.j2x(jObj, 0).val;\n  }\n};\n\nBuilder.prototype.j2x = function(jObj, level) {\n  let attrStr = '';\n  let val = '';\n  for (let key in jObj) {\n    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node only if it is not an attribute\n      if (this.isAttribute(key)) {\n        val += '';\n      }\n    } else if (jObj[key] === null) {\n      // null attribute should be ignored by the attribute list, but should not cause the tag closing\n      if (this.isAttribute(key)) {\n        val += '';\n      } else if (key[0] === '?') {\n        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n      } else {\n        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n      }\n      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextValNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);\n      }else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);\n          val += this.replaceEntitiesValue(newval);\n        } else {\n          val += this.buildTextValNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      const arrLen = jObj[key].length;\n      let listTagVal = \"\";\n      for (let j = 0; j < arrLen; j++) {\n        const item = jObj[key][j];\n        if (typeof item === 'undefined') {\n          // supress undefined node\n        } else if (item === null) {\n          if(key[0] === \"?\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n        } else if (typeof item === 'object') {\n          if(this.options.oneListGroup ){\n            listTagVal += this.j2x(item, level + 1).val;\n          }else{\n            listTagVal += this.processTextOrObjNode(item, key, level)\n          }\n        } else {\n          listTagVal += this.buildTextValNode(item, key, '', level);\n        }\n      }\n      if(this.options.oneListGroup){\n        listTagVal = this.buildObjectNode(listTagVal, key, '', level);\n      }\n      val += listTagVal;\n    } else {\n      //nested node\n      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level)\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nBuilder.prototype.buildAttrPairStr = function(attrName, val){\n  val = this.options.attributeValueProcessor(attrName, '' + val);\n  val = this.replaceEntitiesValue(val);\n  if (this.options.suppressBooleanAttributes && val === \"true\") {\n    return ' ' + attrName;\n  } else return ' ' + attrName + '=\"' + val + '\"';\n}\n\nfunction processTextOrObjNode (object, key, level) {\n  const result = this.j2x(object, level + 1);\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n  } else {\n    return this.buildObjectNode(result.val, key, result.attrStr, level);\n  }\n}\n\nBuilder.prototype.buildObjectNode = function(val, key, attrStr, level) {\n  if(val === \"\"){\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }\n  }else{\n\n    let tagEndExp = '</' + key + this.tagEndChar;\n    let piClosingChar = \"\";\n    \n    if(key[0] === \"?\") {\n      piClosingChar = \"?\";\n      tagEndExp = \"\";\n    }\n  \n    // attrStr is an empty string in case the attribute came as undefined or null\n    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {\n      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );\n    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n      return this.indentate(level) + `<!--${val}-->` + this.newLine;\n    }else {\n      return (\n        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +\n        val +\n        this.indentate(level) + tagEndExp    );\n    }\n  }\n}\n\nBuilder.prototype.closeTag = function(key){\n  let closeTag = \"\";\n  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\n    if(!this.options.suppressUnpairedNode) closeTag = \"/\"\n  }else if(this.options.suppressEmptyNode){ //empty\n    closeTag = \"/\";\n  }else{\n    closeTag = `></${key}`\n  }\n  return closeTag;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n      // return this.buildTagStr(level,key, attrStr);\n    }\n  }\n}\n\nBuilder.prototype.buildTextValNode = function(val, key, attrStr, level) {\n  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;\n  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n    return this.indentate(level) + `<!--${val}-->` +  this.newLine;\n  }else if(key[0] === \"?\") {//PI tag\n    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; \n  }else{\n    let textValue = this.options.tagValueProcessor(key, val);\n    textValue = this.replaceEntitiesValue(textValue);\n  \n    if( textValue === ''){\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }else{\n      return this.indentate(level) + '<' + key + attrStr + '>' +\n         textValue +\n        '</' + key + this.tagEndChar;\n    }\n  }\n}\n\nBuilder.prototype.replaceEntitiesValue = function(textValue){\n  if(textValue && textValue.length > 0 && this.options.processEntities){\n    for (let i=0; i<this.options.entities.length; i++) {\n      const entity = this.options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = Builder;\n","'use strict';\n\nconst validator = require('./validator');\nconst XMLParser = require('./xmlparser/XMLParser');\nconst XMLBuilder = require('./xmlbuilder/json2xml');\n\nmodule.exports = {\n  XMLParser: XMLParser,\n  XMLValidator: validator,\n  XMLBuilder: XMLBuilder\n}","import { exec } from 'child_process';\nimport dedent from 'ts-dedent';\nimport * as path from 'path';\n\ntype CommandOptions = {\n    /**\n     * Path to the PHP binary used to execute the command.\n     */\n    php?: string;\n\n    /**\n     * Path to the Symfony Console entrypoint.\n     */\n    script?: string;\n};\n\nconst defaultOptions: CommandOptions = {\n    php: 'php',\n    script: 'bin/console',\n};\n\nconst prepareSymfonyCommand = (command: string, inputs: string[] = [], options: CommandOptions = {}) => {\n    const finalOptions = {\n        ...defaultOptions,\n        ...options,\n    };\n\n    return [finalOptions.php, finalOptions.script, command]\n        .concat([...inputs, '-v'])\n        .map((part) => `'${part}'`)\n        .join(' ');\n};\n\nconst execSymfonyCommand = async (finalCommand: string) => {\n    return new Promise<string>((resolve, reject) => {\n        exec(finalCommand, (error, stdout, stderr) => {\n            if (error) {\n                reject(\n                    new Error(dedent`\n                    Symfony console failed with exit status ${error.code}:\n                    CMD: ${error.cmd}\n                    Output: ${stdout}\n                    Error output: ${stderr}\n                `)\n                );\n            }\n\n            resolve(stdout);\n        });\n    });\n};\n\n/**\n * Run a Symfony command.\n */\nexport const runSymfonyCommand = async (command: string, inputs: string[] = [], options: CommandOptions = {}) => {\n    const finalCommand = prepareSymfonyCommand(command, inputs, options);\n\n    return execSymfonyCommand(finalCommand);\n};\n\n/**\n * Run a Symfony command with JSON formatted output and get the result as a JS object.\n */\nexport const runSymfonyCommandJson = async <T = any>(\n    command: string,\n    inputs: string[] = [],\n    options: CommandOptions = {}\n): Promise<T> => {\n    const finalCommand = prepareSymfonyCommand(command, [...inputs, '--format=json'], options);\n    const result = await execSymfonyCommand(finalCommand);\n\n    try {\n        return JSON.parse(result);\n    } catch (err) {\n        throw new Error(dedent`\n        Failed to process JSON output for Symfony command.\n        CMD: ${finalCommand}\n        Raw output: ${result}\n        `);\n    }\n};\n\nexport const getKernelProjectDir = async () => {\n    return (\n        await runSymfonyCommandJson<{ [p: string]: string }>('debug:container', ['--parameter=kernel.project_dir'])\n    )['kernel.project_dir'];\n};\n\ntype StorybookBundleConfig = {\n    storybook: {\n        runtime_dir: string;\n    };\n};\n\nexport const getBundleConfig = async () => {\n    return (await runSymfonyCommandJson<StorybookBundleConfig>('debug:config', ['storybook']))['storybook'];\n};\n\ntype SymfonyTwigComponentConfiguration = {\n    twig_component: {\n        anonymous_template_directory: string;\n        defaults: {\n            [p: string]: {\n                name_prefix: string;\n                template_directory: string;\n            };\n        };\n    };\n};\n\nexport const getTwigComponentConfiguration = async () => {\n    return (\n        await runSymfonyCommandJson<SymfonyTwigComponentConfiguration>('debug:config', [\n            'twig_component',\n            '--resolve-env',\n        ])\n    )['twig_component'];\n};\n\nexport type TwigComponentConfiguration = {\n    anonymousTemplateDirectory: string;\n    namespaces: {\n        [p: string]: string;\n    };\n};\n\n/**\n * Attempt to resolve the Twig template path containing sources for the given TwigComponent.\n */\nexport function resolveTwigComponentFile(componentName: string, config: TwigComponentConfiguration) {\n    const nameParts = componentName.split(':');\n    const dirParts = nameParts.slice(0, -1);\n    const filename = `${nameParts.slice(-1)}.html.twig`;\n\n    const lookupPaths: string[] = [];\n\n    for (const namespace in config.namespaces) {\n        if ('' !== namespace && 0 === componentName.indexOf(namespace)) {\n            lookupPaths.push(path.join(config.namespaces[namespace], dirParts.slice(1).join('/')));\n            break;\n        }\n    }\n\n    if (config.namespaces[''] !== undefined) {\n        lookupPaths.push(path.join(config.namespaces[''], dirParts.join('/')));\n    }\n\n    lookupPaths.push(path.join(config.anonymousTemplateDirectory, dirParts.join('/')));\n\n    try {\n        return require.resolve(`./${filename}`, { paths: lookupPaths });\n    } catch (err) {\n        throw new Error(dedent`Unable to find template file for component \"${componentName}\": ${err}`);\n    }\n}\n","export function dedent(\n  templ: TemplateStringsArray | string,\n  ...values: unknown[]\n): string {\n  let strings = Array.from(typeof templ === 'string' ? [templ] : templ);\n\n  // 1. Remove trailing whitespace.\n  strings[strings.length - 1] = strings[strings.length - 1].replace(\n    /\\r?\\n([\\t ]*)$/,\n    '',\n  );\n\n  // 2. Find all line breaks to determine the highest common indentation level.\n  const indentLengths = strings.reduce((arr, str) => {\n    const matches = str.match(/\\n([\\t ]+|(?!\\s).)/g);\n    if (matches) {\n      return arr.concat(\n        matches.map((match) => match.match(/[\\t ]/g)?.length ?? 0),\n      );\n    }\n    return arr;\n  }, <number[]>[]);\n\n  // 3. Remove the common indentation from all strings.\n  if (indentLengths.length) {\n    const pattern = new RegExp(`\\n[\\t ]{${Math.min(...indentLengths)}}`, 'g');\n\n    strings = strings.map((str) => str.replace(pattern, '\\n'));\n  }\n\n  // 4. Remove leading whitespace.\n  strings[0] = strings[0].replace(/^\\r?\\n/, '');\n\n  // 5. Perform interpolation.\n  let string = strings[0];\n\n  values.forEach((value, i) => {\n    // 5.1 Read current indentation level\n    const endentations = string.match(/(?:^|\\n)( *)$/)\n    const endentation = endentations ? endentations[1] : ''\n    let indentedValue = value\n    // 5.2 Add indentation to values with multiline strings\n    if (typeof value === 'string' && value.includes('\\n')) {\n      indentedValue = String(value)\n        .split('\\n')\n        .map((str, i) => {\n          return i === 0 ? str : `${endentation}${str}`\n        })\n        .join('\\n');\n    }\n\n    string += indentedValue + strings[i + 1];\n  });\n\n  return string;\n}\n\nexport default dedent;\n","import {\n    getBundleConfig,\n    getKernelProjectDir,\n    getTwigComponentConfiguration,\n    TwigComponentConfiguration,\n} from './lib/symfony';\nimport { StorybookConfig, SymfonyOptions } from '../types';\nimport { join } from 'path';\nimport { PreviewCompilerPlugin } from './lib/preview-compiler-plugin';\nimport { DevPreviewCompilerPlugin } from './lib/dev-preview-compiler-plugin';\nimport { TwigLoaderPlugin } from './lib/twig-loader-plugin';\nimport { PresetProperty } from '@storybook/types';\nimport dedent from 'ts-dedent';\n\ntype BuildOptions = {\n    twigComponent: TwigComponentConfiguration;\n    runtimeDir: string;\n    projectDir: string;\n    additionalWatchPaths: string[];\n};\n\nconst getBuildOptions = async (symfonyOptions: SymfonyOptions) => {\n    const projectDir = await getKernelProjectDir();\n    const twigComponentsConfig = await getTwigComponentConfiguration();\n\n    const componentNamespaces: { [p: string]: string } = {};\n\n    for (const { name_prefix: namePrefix, template_directory: templateDirectory } of Object.values(\n        twigComponentsConfig.defaults\n    )) {\n        componentNamespaces[namePrefix] = join(projectDir, 'templates', templateDirectory);\n    }\n\n    const anonymousNamespace = join(projectDir, 'templates', twigComponentsConfig['anonymous_template_directory']);\n\n    const runtimeDir = (await getBundleConfig()).runtime_dir;\n\n    return {\n        twigComponent: {\n            anonymousTemplateDirectory: anonymousNamespace,\n            namespaces: componentNamespaces,\n        },\n        runtimeDir,\n        projectDir,\n        additionalWatchPaths: symfonyOptions.additionalWatchPaths || [],\n    } as BuildOptions;\n};\n\nexport const webpack: StorybookConfig['webpack'] = async (config, options) => {\n    const framework = await options.presets.apply('framework');\n\n    const frameworkOptions = typeof framework === 'string' ? {} : framework.options;\n\n    // This options resolution should be done right before creating the build configuration (i.e. not in options presets).\n    const symfonyOptions = await getBuildOptions(frameworkOptions.symfony);\n\n    return {\n        ...config,\n        plugins: [\n            ...(config.plugins || []),\n            ...[\n                options.configType === 'PRODUCTION'\n                    ? PreviewCompilerPlugin.webpack()\n                    : DevPreviewCompilerPlugin.webpack({\n                          projectDir: symfonyOptions.projectDir,\n                          additionalWatchPaths: symfonyOptions.additionalWatchPaths,\n                      }),\n                TwigLoaderPlugin.webpack({ twigComponentConfiguration: symfonyOptions.twigComponent }),\n            ],\n        ],\n        module: {\n            ...config.module,\n            rules: [...(config.module?.rules || [])],\n        },\n    };\n};\n\nexport const previewHead: PresetProperty<'previewHead'> = async (base: any) => dedent`\n    ${base}\n    <!--PREVIEW_HEAD_PLACEHOLDER-->\n    `;\n\nexport const previewBody: PresetProperty<'previewBody'> = async (base: any) => dedent`\n    ${base}\n    <!--PREVIEW_BODY_PLACEHOLDER-->\n    `;\n","import { createUnplugin } from 'unplugin';\nimport { runSymfonyCommand } from './symfony';\nimport HtmlWebpackPlugin from 'html-webpack-plugin';\nimport { logger } from '@storybook/node-logger';\nimport dedent from 'ts-dedent';\nimport { injectPreviewHtml } from './injectPreviewHtml';\n\nconst PLUGIN_NAME = 'preview-plugin';\n\n/**\n * Compile preview HTML.\n */\nexport const PreviewCompilerPlugin = createUnplugin(() => {\n    return {\n        name: PLUGIN_NAME,\n        webpack(compiler) {\n            compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation) => {\n                // Inject previewHead and previewBody in the compiled iframe.html before it is output\n                HtmlWebpackPlugin.getHooks(compilation).afterTemplateExecution.tapPromise(\n                    PLUGIN_NAME,\n                    async (params) => {\n                        try {\n                            const previewHtml = await runSymfonyCommand('storybook:generate-preview');\n                            params.html = injectPreviewHtml(previewHtml, params.html);\n\n                            return params;\n                        } catch (err) {\n                            logger.error(dedent`\n                            Failed to inject Symfony preview template in main iframe.html.\n                            ERR: ${err}\n                            `);\n                            return params;\n                        }\n                    }\n                );\n            });\n        },\n    };\n});\n","import { JSDOM } from 'jsdom';\n\nexport const injectPreviewHtml = (previewHtml: string, targetHtml: string) => {\n    const previewDom = new JSDOM(previewHtml);\n\n    const previewHead = previewDom.window.document.head;\n    const previewBody = previewDom.window.document.body;\n\n    return targetHtml\n        .replace('<!--PREVIEW_HEAD_PLACEHOLDER-->', previewHead.innerHTML)\n        .replace('<!--PREVIEW_BODY_PLACEHOLDER-->', previewBody.innerHTML);\n};\n","import { createUnplugin } from 'unplugin';\nimport dedent from 'ts-dedent';\nimport VirtualModulesPlugin from 'webpack-virtual-modules';\nimport { runSymfonyCommand } from './symfony';\nimport { computeAdditionalWatchPaths } from './computeAdditionalWatchPaths';\nimport HtmlWebpackPlugin from 'html-webpack-plugin';\nimport { logger } from '@storybook/node-logger';\nimport { injectPreviewHtml } from './injectPreviewHtml';\n\nconst PLUGIN_NAME = 'dev-preview-plugin';\n\nexport type Options = {\n    projectDir: string;\n    additionalWatchPaths: string[];\n};\n\n/**\n * Compile preview HTML for dev with HMR .\n */\nexport const DevPreviewCompilerPlugin = createUnplugin<Options>((options) => {\n    const { projectDir, additionalWatchPaths } = options;\n\n    return {\n        name: PLUGIN_NAME,\n        enforce: 'post',\n        transformInclude(id) {\n            return /storybook-config-entry\\.js$/.test(id);\n        },\n        async transform(code) {\n            return dedent`\n        import { symfonyPreview } from './symfony-preview.js';\n        \n        ${code}\n\n        window.__SYMFONY_PREVIEW__ = symfonyPreview;\n        if (import.meta.webpackHot) {\n            import.meta.webpackHot.accept('./symfony-preview.js', () => {\n                const iframe = window.top.document.getElementById('storybook-preview-iframe');\n                if (iframe) {\n                    iframe.src = iframe.src;\n                }\n            });\n        }\n        `;\n        },\n        webpack(compiler) {\n            // Virtual plugin for preview module\n            const v = new VirtualModulesPlugin();\n            v.apply(compiler);\n\n            let previewHtml = '';\n\n            // Compile preview before each compilation in watch mode\n            compiler.hooks.watchRun.tapPromise(PLUGIN_NAME, async () => {\n                previewHtml = await runSymfonyCommand('storybook:generate-preview');\n\n                // Write preview module\n                v.writeModule(\n                    './symfony-preview.js',\n                    dedent`\n                    export const symfonyPreview = {\n                        html: \\`${previewHtml}\\`,\n                    };`\n                );\n            });\n\n            compiler.hooks.afterCompile.tap(PLUGIN_NAME, (compilation) => {\n                if ('HtmlWebpackCompiler' == compilation.name) {\n                    // Register additional watch paths for HMR\n                    const resolvedWatchPaths = computeAdditionalWatchPaths(additionalWatchPaths, projectDir);\n                    compilation.contextDependencies.addAll(resolvedWatchPaths.dirs);\n                    compilation.fileDependencies.addAll(resolvedWatchPaths.files);\n                }\n            });\n\n            compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation) => {\n                // Inject previewHead and previewBody in the compiled iframe.html before it is output\n                HtmlWebpackPlugin.getHooks(compilation).afterTemplateExecution.tapPromise(\n                    PLUGIN_NAME,\n                    async (params) => {\n                        try {\n                            params.html = injectPreviewHtml(previewHtml, params.html);\n                            return params;\n                        } catch (err) {\n                            logger.error(dedent`\n                            Failed to inject Symfony preview template in main iframe.html.\n                            ERR: ${err}\n                            `);\n                            return params;\n                        }\n                    }\n                );\n            });\n        },\n    };\n});\n","import { join } from 'path';\nimport isGlob from 'is-glob';\nimport { glob } from 'glob';\nimport fs from 'node:fs';\nimport { logger } from '@storybook/node-logger';\nimport dedent from 'ts-dedent';\n\ntype AdditionalWatchPaths = {\n    dirs: string[];\n    files: string[];\n};\n\nexport const computeAdditionalWatchPaths = (paths: string[], baseDir: string) => {\n    const result: AdditionalWatchPaths = {\n        dirs: [],\n        files: [],\n    };\n\n    paths\n        .map((v) => join(baseDir, v))\n        .forEach((watchPath) => {\n            if (isGlob(watchPath)) {\n                result.files.push(\n                    ...glob.sync(watchPath, {\n                        dot: true,\n                        absolute: true,\n                    })\n                );\n            } else if (fs.existsSync(watchPath)) {\n                const stats = fs.lstatSync(watchPath);\n                (stats.isDirectory() ? result.dirs : result.files).push(watchPath);\n            } else {\n                logger.warn(dedent`\n                    Ignoring additional watch path '${watchPath}': path doesn't exists.\n                `);\n            }\n        });\n\n    return result;\n};\n","import expand from 'brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\ntype Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  nobrace?: boolean\n  nocomment?: boolean\n  nonegate?: boolean\n  debug?: boolean\n  noglobstar?: boolean\n  noext?: boolean\n  nonull?: boolean\n  windowsPathsNoEscape?: boolean\n  allowWindowsEscape?: boolean\n  partial?: boolean\n  dot?: boolean\n  nocase?: boolean\n  nocaseMagicOnly?: boolean\n  magicalBraces?: boolean\n  matchBase?: boolean\n  flipNegate?: boolean\n  preserveMultipleSlashes?: boolean\n  optimizationLevel?: number\n  platform?: Platform\n  windowsNoMagicRoot?: boolean\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) => !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) => f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) => f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n      process.platform\n    : 'posix'\n) as Platform\ntype Sep = '\\\\' | '/'\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {}\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) => orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (list: string[], pattern: string, options: MinimatchOptions = {}) =>\n      orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined\n        ? options.windowsNoMagicRoot\n        : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes\n        )\n        if (!matched) continue\n        globParts[i] = matched\n        globParts[j] = []\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file: string[], pattern: ParseReturn[], partial: boolean = false) {\n    const options = this.options\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [file[fdi], pattern[pdi] as string]\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          if (pdi > fdi) {\n            pattern = pattern.slice( pdi)\n          } else if (fdi > pdi) {\n            file = file.slice(fdi)\n          }\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    this.debug('matchOne', this, { file, pattern })\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (\n      var fi = 0, pi = 0, fl = file.length, pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (\n              file[fi] === '.' ||\n              file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')\n            )\n              return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (\n              swallowee === '.' ||\n              swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')\n            ) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) {\n            return true\n          }\n        }\n        /* c8 ignore stop */\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? starDotExtTestNocaseDot\n            : starDotExtTestNocase\n          : options.dot\n          ? starDotExtTestDot\n          : starDotExtTest\n      )(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? qmarksTestNocaseDot\n            : qmarksTestNocase\n          : options.dot\n          ? qmarksTestDot\n          : qmarksTest\n      )(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    return fastTest ? Object.assign(re, { test: fastTest }) : re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar\n      ? star\n      : options.dot\n      ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return typeof p === 'string'\n            ? regExpEscape(p)\n            : p === GLOBSTAR\n            ? GLOBSTAR\n            : p._src\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        return pp.filter(p => p !== GLOBSTAR).join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n","const MAX_PATTERN_LENGTH = 1024 * 64\nexport const assertValidPattern: (pattern: any) => void = (\n  pattern: any\n): asserts pattern is string => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n","// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false],\n}\n\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s: string) => s.replace(/[[\\]\\\\-]/g, '\\\\$&')\n// escape all regexp magic characters\nconst regexpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges: string[]): string => ranges.join('')\n\nexport type ParseClassResult = [\n  src: string,\n  uFlag: boolean,\n  consumed: number,\n  hasMagic: boolean\n]\n\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (\n  glob: string,\n  position: number\n): ParseClassResult => {\n  const pos = position\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression')\n  }\n  /* c8 ignore stop */\n  const ranges: string[] = []\n  const negs: string[] = []\n\n  let i = pos + 1\n  let sawStart = false\n  let uflag = false\n  let escaping = false\n  let negate = false\n  let endPos = pos\n  let rangeStart = ''\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i)\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true\n      i++\n      continue\n    }\n\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1\n      break\n    }\n\n    sawStart = true\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true\n        i++\n        continue\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true]\n          }\n          i += cls.length\n          if (neg) negs.push(unip)\n          else ranges.push(unip)\n          uflag = uflag || u\n          continue WHILE\n        }\n      }\n    }\n\n    // now it's just a normal character, effectively\n    escaping = false\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c))\n      }\n      rangeStart = ''\n      i++\n      continue\n    }\n\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'))\n      i += 2\n      continue\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c\n      i += 2\n      continue\n    }\n\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c))\n    i++\n  }\n\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false]\n  }\n\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true]\n  }\n\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (\n    negs.length === 0 &&\n    ranges.length === 1 &&\n    /^\\\\?.$/.test(ranges[0]) &&\n    !negate\n  ) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]\n    return [regexpEscape(r), false, endPos - pos, false]\n  }\n\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'\n  const comb =\n    ranges.length && negs.length\n      ? '(' + sranges + '|' + snegs + ')'\n      : ranges.length\n      ? sranges\n      : snegs\n\n  return [comb, uflag, endPos - pos, true]\n}\n","import { MinimatchOptions } from './index.js'\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  return windowsPathsNoEscape\n    ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n    : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1')\n}\n","// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null\n        ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n        : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) this.#fillNegs()\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd()\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string'\n              ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n              : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      this.#parts = [s]\n      this.type = null\n      this.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    // XXX abstract out this map method\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot\n        ? ''\n        : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!'\n          ? // !() must match something,but !(x) can match ''\n            '))' +\n            (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n            star +\n            ')'\n          : this.type === '@'\n          ? ')'\n          : this.type === '?'\n          ? ')?'\n          : this.type === '+' && bodyDotAllowed\n          ? ')'\n          : this.type === '*' && bodyDotAllowed\n          ? `)?`\n          : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #partsToRegExp(dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty\n        else re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n","import { MinimatchOptions } from './index.js'\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  return windowsPathsNoEscape\n    ? s.replace(/[?*()[\\]]/g, '[$&]')\n    : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&')\n}\n","/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   */\n  export type DisposeReason = 'evict' | 'set' | 'delete'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Status object that may be passed to {@link LRUCache#fetch},\n   * {@link LRUCache#get}, {@link LRUCache#set}, and {@link LRUCache#has}.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no fetchMethod, so {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed\n     * by default, and MAY live in the cache long after they have expired.\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * Must be an integer number of ms. If set to 0, this indicates \"no TTL\"\n     *\n     * @default 0\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     * Note that this may significantly degrade performance,\n     * especially if the cache is storing a large number of items.\n     * It is almost always best to just leave the stale items in\n     * the cache, and let them fall out as new items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * @default false\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * Update the age of items on {@link LRUCache#get}, renewing their TTL\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * @default false\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * Update the age of items on {@link LRUCache#has}, renewing their TTL\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * @default false\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the cache.\n     * This can be handy if you want to close file descriptors or do other\n     * cleanup tasks when items are no longer accessible. Called with `key,\n     * value`.  It's called before actually removing the item from the\n     * internal cache, so it is *NOT* safe to re-add them.\n     *\n     * Use {@link OptionsBase.disposeAfter} if you wish to dispose items after\n     * they have been full removed, when it is safe to add them back to the\n     * cache.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when\n     * setting a new value for an existing key (ie, when updating a value\n     * rather than inserting a new value).  Note that the TTL value is\n     * _always_ set (if provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * If you wish to track item size, you must provide a maxSize\n     * note that we still will only keep up to max *actual items*,\n     * if max is set, so size tracking may cause fewer than max items\n     * to be stored.  At the extreme, a single item of maxSize size\n     * will cause everything else in the cache to be dropped when it\n     * is added.  Use with caution!\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod}, then it will not be stored in the\n     * cache.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the\n     * {@link LRUCache#fetch} fails, not any other times.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches an `'abort'`\n     * event, whether user-triggered, or due to internal cache behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls are not\n     * immediately resolved or rejected when they are aborted, and instead\n     * take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown> implements Map<K,V> {\n  // properties coming in from the options of these, only max and maxSize\n  // really *need* to be protected. The rest can be modified, as they just\n  // set defaults for various methods.\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the remaining TTL time for a given entry key\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.delete(this.#keyList[index] as K)\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string description of an object.\n   * Called by the built-in method Object.prototype.toString.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to Array.find().  fn is called as fn(value, key, cache).\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from\n   * most recently used to least recently used.  fn is called as\n   * fn(value, key, cache).  Does not update age or recenty of use.\n   * Does not iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.delete(this.#keyList[i] as K)\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a\n   * single key. Always returns stale values, if their info is found in the\n   * cache, so be sure to check for expired TTLs if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to cache.load()\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   * Note that the shape of the resulting cache may be different if the\n   * same options are not used in both caches.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.delete(k)\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.delete(k)\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.delete(k)\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   */\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k)\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.clear()\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, 'delete')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, 'delete'])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, 'delete')\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, 'delete'])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n","import { LRUCache } from 'lru-cache'\nimport { posix, win32 } from 'path'\n\nimport { fileURLToPath } from 'url'\n\nimport * as actualFS from 'fs'\nimport {\n  lstatSync,\n  readdir as readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync as rps,\n} from 'fs'\nconst realpathSync = rps.native\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nimport { lstat, readdir, readlink, realpath } from 'fs/promises'\n\nimport type { Dirent, Stats } from 'fs'\nimport { Minipass } from 'minipass'\n\n/**\n * An object that will be used to override the default `fs`\n * methods.  Any methods that are not overridden will use Node's\n * built-in implementations.\n *\n * - lstatSync\n * - readdir (callback `withFileTypes` Dirent variant, used for\n *   readdirCB and most walks)\n * - readdirSync\n * - readlinkSync\n * - realpathSync\n * - promises: Object containing the following async methods:\n *   - lstat\n *   - readdir (Dirent variant only)\n *   - readlink\n *   - realpath\n */\nexport interface FSOption {\n  lstatSync?: (path: string) => Stats\n  readdir?: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any\n  ) => void\n  readdirSync?: (\n    path: string,\n    options: { withFileTypes: true }\n  ) => Dirent[]\n  readlinkSync?: (path: string) => string\n  realpathSync?: (path: string) => string\n  promises?: {\n    lstat?: (path: string) => Promise<Stats>\n    readdir?: (\n      path: string,\n      options: { withFileTypes: true }\n    ) => Promise<Dirent[]>\n    readlink?: (path: string) => Promise<string>\n    realpath?: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\ninterface FSValue {\n  lstatSync: (path: string) => Stats\n  readdir: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any\n  ) => void\n  readdirSync: (path: string, options: { withFileTypes: true }) => Dirent[]\n  readlinkSync: (path: string) => string\n  realpathSync: (path: string) => string\n  promises: {\n    lstat: (path: string) => Promise<Stats>\n    readdir: (\n      path: string,\n      options: { withFileTypes: true }\n    ) => Promise<Dirent[]>\n    readlink: (path: string) => Promise<string>\n    realpath: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\nconst defaultFS: FSValue = {\n  lstatSync,\n  readdir: readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync,\n  promises: {\n    lstat,\n    readdir,\n    readlink,\n    realpath,\n  },\n}\n\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption?: FSOption): FSValue =>\n  !fsOption || fsOption === defaultFS || fsOption === actualFS\n    ? defaultFS\n    : {\n        ...defaultFS,\n        ...fsOption,\n        promises: {\n          ...defaultFS.promises,\n          ...(fsOption.promises || {}),\n        },\n      }\n\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i\nconst uncToDrive = (rootPath: string): string =>\n  rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\')\n\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/\n\nconst UNKNOWN = 0 // may not even exist, for all we know\nconst IFIFO = 0b0001\nconst IFCHR = 0b0010\nconst IFDIR = 0b0100\nconst IFBLK = 0b0110\nconst IFREG = 0b1000\nconst IFLNK = 0b1010\nconst IFSOCK = 0b1100\nconst IFMT = 0b1111\n\nexport type Type =\n  | 'Unknown'\n  | 'FIFO'\n  | 'CharacterDevice'\n  | 'Directory'\n  | 'BlockDevice'\n  | 'File'\n  | 'SymbolicLink'\n  | 'Socket'\n\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT\n\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 0b0000_0001_0000\n// set after a successful lstat()\nconst LSTAT_CALLED = 0b0000_0010_0000\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 0b0000_0100_0000\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 0b0000_1000_0000\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 0b0001_0000_0000\n// set if we know realpath() will fail\nconst ENOREALPATH = 0b0010_0000_0000\n\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH\nconst TYPEMASK = 0b0011_1111_1111\n\nconst entToType = (s: Dirent | Stats) =>\n  s.isFile()\n    ? IFREG\n    : s.isDirectory()\n    ? IFDIR\n    : s.isSymbolicLink()\n    ? IFLNK\n    : s.isCharacterDevice()\n    ? IFCHR\n    : s.isBlockDevice()\n    ? IFBLK\n    : s.isSocket()\n    ? IFSOCK\n    : s.isFIFO()\n    ? IFIFO\n    : UNKNOWN\n\n// normalize unicode path names\nconst normalizeCache = new Map<string, string>()\nconst normalize = (s: string) => {\n  const c = normalizeCache.get(s)\n  if (c) return c\n  const n = s.normalize('NFKD')\n  normalizeCache.set(s, n)\n  return n\n}\n\nconst normalizeNocaseCache = new Map<string, string>()\nconst normalizeNocase = (s: string) => {\n  const c = normalizeNocaseCache.get(s)\n  if (c) return c\n  const n = normalize(s.toLowerCase())\n  normalizeNocaseCache.set(s, n)\n  return n\n}\n\n/**\n * Options that may be provided to the Path constructor\n */\nexport interface PathOpts {\n  fullpath?: string\n  relative?: string\n  relativePosix?: string\n  parent?: PathBase\n  /**\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nexport class ResolveCache extends LRUCache<string, string> {\n  constructor() {\n    super({ max: 256 })\n  }\n}\n\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nexport class ChildrenCache extends LRUCache<PathBase, Children> {\n  constructor(maxSize: number = 16 * 1024) {\n    super({\n      maxSize,\n      // parent + children\n      sizeCalculation: a => a.length + 1,\n    })\n  }\n}\n\n/**\n * Array of Path objects, plus a marker indicating the first provisional entry\n *\n * @internal\n */\nexport type Children = PathBase[] & { provisional: number }\n\nconst setAsCwd = Symbol('PathScurry setAsCwd')\n\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nexport abstract class PathBase implements Dirent {\n  /**\n   * the basename of this path\n   *\n   * **Important**: *always* test the path name against any test string\n   * usingthe {@link isNamed} method, and not by directly comparing this\n   * string. Otherwise, unicode path strings that the system sees as identical\n   * will not be properly treated as the same path, leading to incorrect\n   * behavior and possible security issues.\n   */\n  name: string\n  /**\n   * the Path entry corresponding to the path root.\n   *\n   * @internal\n   */\n  root: PathBase\n  /**\n   * All roots found within the current PathScurry family\n   *\n   * @internal\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * a reference to the parent path, or undefined in the case of root entries\n   *\n   * @internal\n   */\n  parent?: PathBase\n  /**\n   * boolean indicating whether paths are compared case-insensitively\n   * @internal\n   */\n  nocase: boolean\n\n  /**\n   * the string or regexp used to split paths. On posix, it is `'/'`, and on\n   * windows it is a RegExp matching either `'/'` or `'\\\\'`\n   */\n  abstract splitSep: string | RegExp\n  /**\n   * The path separator string to use when joining paths\n   */\n  abstract sep: string\n\n  // potential default fs override\n  #fs: FSValue\n\n  // Stats fields\n  #dev?: number\n  get dev() {\n    return this.#dev\n  }\n  #mode?: number\n  get mode() {\n    return this.#mode\n  }\n  #nlink?: number\n  get nlink() {\n    return this.#nlink\n  }\n  #uid?: number\n  get uid() {\n    return this.#uid\n  }\n  #gid?: number\n  get gid() {\n    return this.#gid\n  }\n  #rdev?: number\n  get rdev() {\n    return this.#rdev\n  }\n  #blksize?: number\n  get blksize() {\n    return this.#blksize\n  }\n  #ino?: number\n  get ino() {\n    return this.#ino\n  }\n  #size?: number\n  get size() {\n    return this.#size\n  }\n  #blocks?: number\n  get blocks() {\n    return this.#blocks\n  }\n  #atimeMs?: number\n  get atimeMs() {\n    return this.#atimeMs\n  }\n  #mtimeMs?: number\n  get mtimeMs() {\n    return this.#mtimeMs\n  }\n  #ctimeMs?: number\n  get ctimeMs() {\n    return this.#ctimeMs\n  }\n  #birthtimeMs?: number\n  get birthtimeMs() {\n    return this.#birthtimeMs\n  }\n  #atime?: Date\n  get atime() {\n    return this.#atime\n  }\n  #mtime?: Date\n  get mtime() {\n    return this.#mtime\n  }\n  #ctime?: Date\n  get ctime() {\n    return this.#ctime\n  }\n  #birthtime?: Date\n  get birthtime() {\n    return this.#birthtime\n  }\n\n  #matchName: string\n  #depth?: number\n  #fullpath?: string\n  #fullpathPosix?: string\n  #relative?: string\n  #relativePosix?: string\n  #type: number\n  #children: ChildrenCache\n  #linkTarget?: PathBase\n  #realpath?: PathBase\n\n  /**\n   * This property is for compatibility with the Dirent class as of\n   * Node v20, where Dirent['path'] refers to the path of the directory\n   * that was passed to readdir.  So, somewhat counterintuitively, this\n   * property refers to the *parent* path, not the path object itself.\n   * For root entries, it's the path to the entry itself.\n   */\n  get path(): string {\n    return (this.parent || this).fullpath()\n  }\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    this.name = name\n    this.#matchName = nocase ? normalizeNocase(name) : normalize(name)\n    this.#type = type & TYPEMASK\n    this.nocase = nocase\n    this.roots = roots\n    this.root = root || this\n    this.#children = children\n    this.#fullpath = opts.fullpath\n    this.#relative = opts.relative\n    this.#relativePosix = opts.relativePosix\n    this.parent = opts.parent\n    if (this.parent) {\n      this.#fs = this.parent.#fs\n    } else {\n      this.#fs = fsFromOption(opts.fs)\n    }\n  }\n\n  /**\n   * Returns the depth of the Path object from its root.\n   *\n   * For example, a path at `/foo/bar` would have a depth of 2.\n   */\n  depth(): number {\n    if (this.#depth !== undefined) return this.#depth\n    if (!this.parent) return (this.#depth = 0)\n    return (this.#depth = this.parent.depth() + 1)\n  }\n\n  /**\n   * @internal\n   */\n  abstract getRootString(path: string): string\n  /**\n   * @internal\n   */\n  abstract getRoot(rootPath: string): PathBase\n  /**\n   * @internal\n   */\n  abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase\n\n  /**\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Get the Path object referenced by the string path, resolved from this Path\n   */\n  resolve(path?: string): PathBase {\n    if (!path) {\n      return this\n    }\n    const rootPath = this.getRootString(path)\n    const dir = path.substring(rootPath.length)\n    const dirParts = dir.split(this.splitSep)\n    const result: PathBase = rootPath\n      ? this.getRoot(rootPath).#resolveParts(dirParts)\n      : this.#resolveParts(dirParts)\n    return result\n  }\n\n  #resolveParts(dirParts: string[]) {\n    let p: PathBase = this\n    for (const part of dirParts) {\n      p = p.child(part)\n    }\n    return p\n  }\n\n  /**\n   * Returns the cached children Path objects, if still available.  If they\n   * have fallen out of the cache, then returns an empty array, and resets the\n   * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n   * lookup.\n   *\n   * @internal\n   */\n  children(): Children {\n    const cached = this.#children.get(this)\n    if (cached) {\n      return cached\n    }\n    const children: Children = Object.assign([], { provisional: 0 })\n    this.#children.set(this, children)\n    this.#type &= ~READDIR_CALLED\n    return children\n  }\n\n  /**\n   * Resolves a path portion and returns or creates the child Path.\n   *\n   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n   * `'..'`.\n   *\n   * This should not be called directly.  If `pathPart` contains any path\n   * separators, it will lead to unsafe undefined behavior.\n   *\n   * Use `Path.resolve()` instead.\n   *\n   * @internal\n   */\n  child(pathPart: string, opts?: PathOpts): PathBase {\n    if (pathPart === '' || pathPart === '.') {\n      return this\n    }\n    if (pathPart === '..') {\n      return this.parent || this\n    }\n\n    // find the child\n    const children = this.children()\n    const name = this.nocase\n      ? normalizeNocase(pathPart)\n      : normalize(pathPart)\n    for (const p of children) {\n      if (p.#matchName === name) {\n        return p\n      }\n    }\n\n    // didn't find it, create provisional child, since it might not\n    // actually exist.  If we know the parent isn't a dir, then\n    // in fact it CAN'T exist.\n    const s = this.parent ? this.sep : ''\n    const fullpath = this.#fullpath\n      ? this.#fullpath + s + pathPart\n      : undefined\n    const pchild = this.newChild(pathPart, UNKNOWN, {\n      ...opts,\n      parent: this,\n      fullpath,\n    })\n\n    if (!this.canReaddir()) {\n      pchild.#type |= ENOENT\n    }\n\n    // don't have to update provisional, because if we have real children,\n    // then provisional is set to children.length, otherwise a lower number\n    children.push(pchild)\n    return pchild\n  }\n\n  /**\n   * The relative path from the cwd. If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpath()\n   */\n  relative(): string {\n    if (this.#relative !== undefined) {\n      return this.#relative\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relative = this.name)\n    }\n    const pv = p.relative()\n    return pv + (!pv || !p.parent ? '' : this.sep) + name\n  }\n\n  /**\n   * The relative path from the cwd, using / as the path separator.\n   * If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpathPosix()\n   * On posix systems, this is identical to relative().\n   */\n  relativePosix(): string {\n    if (this.sep === '/') return this.relative()\n    if (this.#relativePosix !== undefined) return this.#relativePosix\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relativePosix = this.fullpathPosix())\n    }\n    const pv = p.relativePosix()\n    return pv + (!pv || !p.parent ? '' : '/') + name\n  }\n\n  /**\n   * The fully resolved path string for this Path entry\n   */\n  fullpath(): string {\n    if (this.#fullpath !== undefined) {\n      return this.#fullpath\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#fullpath = this.name)\n    }\n    const pv = p.fullpath()\n    const fp = pv + (!p.parent ? '' : this.sep) + name\n    return (this.#fullpath = fp)\n  }\n\n  /**\n   * On platforms other than windows, this is identical to fullpath.\n   *\n   * On windows, this is overridden to return the forward-slash form of the\n   * full UNC path.\n   */\n  fullpathPosix(): string {\n    if (this.#fullpathPosix !== undefined) return this.#fullpathPosix\n    if (this.sep === '/') return (this.#fullpathPosix = this.fullpath())\n    if (!this.parent) {\n      const p = this.fullpath().replace(/\\\\/g, '/')\n      if (/^[a-z]:\\//i.test(p)) {\n        return (this.#fullpathPosix = `//?/${p}`)\n      } else {\n        return (this.#fullpathPosix = p)\n      }\n    }\n    const p = this.parent\n    const pfpp = p.fullpathPosix()\n    const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name\n    return (this.#fullpathPosix = fpp)\n  }\n\n  /**\n   * Is the Path of an unknown type?\n   *\n   * Note that we might know *something* about it if there has been a previous\n   * filesystem operation, for example that it does not exist, or is not a\n   * link, or whether it has child entries.\n   */\n  isUnknown(): boolean {\n    return (this.#type & IFMT) === UNKNOWN\n  }\n\n  isType(type: Type): boolean {\n    return this[`is${type}`]()\n  }\n\n  getType(): Type {\n    return this.isUnknown()\n      ? 'Unknown'\n      : this.isDirectory()\n      ? 'Directory'\n      : this.isFile()\n      ? 'File'\n      : this.isSymbolicLink()\n      ? 'SymbolicLink'\n      : this.isFIFO()\n      ? 'FIFO'\n      : this.isCharacterDevice()\n      ? 'CharacterDevice'\n      : this.isBlockDevice()\n      ? 'BlockDevice'\n      : /* c8 ignore start */ this.isSocket()\n      ? 'Socket'\n      : 'Unknown'\n    /* c8 ignore stop */\n  }\n\n  /**\n   * Is the Path a regular file?\n   */\n  isFile(): boolean {\n    return (this.#type & IFMT) === IFREG\n  }\n\n  /**\n   * Is the Path a directory?\n   */\n  isDirectory(): boolean {\n    return (this.#type & IFMT) === IFDIR\n  }\n\n  /**\n   * Is the path a character device?\n   */\n  isCharacterDevice(): boolean {\n    return (this.#type & IFMT) === IFCHR\n  }\n\n  /**\n   * Is the path a block device?\n   */\n  isBlockDevice(): boolean {\n    return (this.#type & IFMT) === IFBLK\n  }\n\n  /**\n   * Is the path a FIFO pipe?\n   */\n  isFIFO(): boolean {\n    return (this.#type & IFMT) === IFIFO\n  }\n\n  /**\n   * Is the path a socket?\n   */\n  isSocket(): boolean {\n    return (this.#type & IFMT) === IFSOCK\n  }\n\n  /**\n   * Is the path a symbolic link?\n   */\n  isSymbolicLink(): boolean {\n    return (this.#type & IFLNK) === IFLNK\n  }\n\n  /**\n   * Return the entry if it has been subject of a successful lstat, or\n   * undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* simply\n   * mean that we haven't called lstat on it.\n   */\n  lstatCached(): PathBase | undefined {\n    return this.#type & LSTAT_CALLED ? this : undefined\n  }\n\n  /**\n   * Return the cached link target if the entry has been the subject of a\n   * successful readlink, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readlink() has been called at some point.\n   */\n  readlinkCached(): PathBase | undefined {\n    return this.#linkTarget\n  }\n\n  /**\n   * Returns the cached realpath target if the entry has been the subject\n   * of a successful realpath, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * realpath() has been called at some point.\n   */\n  realpathCached(): PathBase | undefined {\n    return this.#realpath\n  }\n\n  /**\n   * Returns the cached child Path entries array if the entry has been the\n   * subject of a successful readdir(), or [] otherwise.\n   *\n   * Does not read the filesystem, so an empty array *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readdir() has been called recently enough to still be valid.\n   */\n  readdirCached(): PathBase[] {\n    const children = this.children()\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n   * any indication that readlink will definitely fail.\n   *\n   * Returns false if the path is known to not be a symlink, if a previous\n   * readlink failed, or if the entry does not exist.\n   */\n  canReadlink(): boolean {\n    if (this.#linkTarget) return true\n    if (!this.parent) return false\n    // cases where it cannot possibly succeed\n    const ifmt = this.#type & IFMT\n    return !(\n      (ifmt !== UNKNOWN && ifmt !== IFLNK) ||\n      this.#type & ENOREADLINK ||\n      this.#type & ENOENT\n    )\n  }\n\n  /**\n   * Return true if readdir has previously been successfully called on this\n   * path, indicating that cachedReaddir() is likely valid.\n   */\n  calledReaddir(): boolean {\n    return !!(this.#type & READDIR_CALLED)\n  }\n\n  /**\n   * Returns true if the path is known to not exist. That is, a previous lstat\n   * or readdir failed to verify its existence when that would have been\n   * expected, or a parent entry was marked either enoent or enotdir.\n   */\n  isENOENT(): boolean {\n    return !!(this.#type & ENOENT)\n  }\n\n  /**\n   * Return true if the path is a match for the given path name.  This handles\n   * case sensitivity and unicode normalization.\n   *\n   * Note: even on case-sensitive systems, it is **not** safe to test the\n   * equality of the `.name` property to determine whether a given pathname\n   * matches, due to unicode normalization mismatches.\n   *\n   * Always use this method instead of testing the `path.name` property\n   * directly.\n   */\n  isNamed(n: string): boolean {\n    return !this.nocase\n      ? this.#matchName === normalize(n)\n      : this.#matchName === normalizeNocase(n)\n  }\n\n  /**\n   * Return the Path object corresponding to the target of a symbolic link.\n   *\n   * If the Path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   */\n  async readlink(): Promise<PathBase | undefined> {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = await this.#fs.promises.readlink(this.fullpath())\n      const linkTarget = this.parent.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  /**\n   * Synchronous {@link PathBase.readlink}\n   */\n  readlinkSync(): PathBase | undefined {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = this.#fs.readlinkSync(this.fullpath())\n      const linkTarget = this.parent.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  #readdirSuccess(children: Children) {\n    // succeeded, mark readdir called bit\n    this.#type |= READDIR_CALLED\n    // mark all remaining provisional children as ENOENT\n    for (let p = children.provisional; p < children.length; p++) {\n      children[p].#markENOENT()\n    }\n  }\n\n  #markENOENT() {\n    // mark as UNKNOWN and ENOENT\n    if (this.#type & ENOENT) return\n    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN\n    this.#markChildrenENOENT()\n  }\n\n  #markChildrenENOENT() {\n    // all children are provisional and do not exist\n    const children = this.children()\n    children.provisional = 0\n    for (const p of children) {\n      p.#markENOENT()\n    }\n  }\n\n  #markENOREALPATH() {\n    this.#type |= ENOREALPATH\n    this.#markENOTDIR()\n  }\n\n  // save the information when we know the entry is not a dir\n  #markENOTDIR() {\n    // entry is not a directory, so any children can't exist.\n    // this *should* be impossible, since any children created\n    // after it's been marked ENOTDIR should be marked ENOENT,\n    // so it won't even get to this point.\n    /* c8 ignore start */\n    if (this.#type & ENOTDIR) return\n    /* c8 ignore stop */\n    let t = this.#type\n    // this could happen if we stat a dir, then delete it,\n    // then try to read it or one of its children.\n    if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN\n    this.#type = t | ENOTDIR\n    this.#markChildrenENOENT()\n  }\n\n  #readdirFail(code: string = '') {\n    // markENOTDIR and markENOENT also set provisional=0\n    if (code === 'ENOTDIR' || code === 'EPERM') {\n      this.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      this.#markENOENT()\n    } else {\n      this.children().provisional = 0\n    }\n  }\n\n  #lstatFail(code: string = '') {\n    // Windows just raises ENOENT in this case, disable for win CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR') {\n      // already know it has a parent by this point\n      const p = this.parent as PathBase\n      p.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      /* c8 ignore stop */\n      this.#markENOENT()\n    }\n  }\n\n  #readlinkFail(code: string = '') {\n    let ter = this.#type\n    ter |= ENOREADLINK\n    if (code === 'ENOENT') ter |= ENOENT\n    // windows gets a weird error when you try to readlink a file\n    if (code === 'EINVAL' || code === 'UNKNOWN') {\n      // exists, but not a symlink, we don't know WHAT it is, so remove\n      // all IFMT bits.\n      ter &= IFMT_UNKNOWN\n    }\n    this.#type = ter\n    // windows just gets ENOENT in this case.  We do cover the case,\n    // just disabled because it's impossible on Windows CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR' && this.parent) {\n      this.parent.#markENOTDIR()\n    }\n    /* c8 ignore stop */\n  }\n\n  #readdirAddChild(e: Dirent, c: Children) {\n    return (\n      this.#readdirMaybePromoteChild(e, c) ||\n      this.#readdirAddNewChild(e, c)\n    )\n  }\n\n  #readdirAddNewChild(e: Dirent, c: Children): PathBase {\n    // alloc new entry at head, so it's never provisional\n    const type = entToType(e)\n    const child = this.newChild(e.name, type, { parent: this })\n    const ifmt = child.#type & IFMT\n    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n      child.#type |= ENOTDIR\n    }\n    c.unshift(child)\n    c.provisional++\n    return child\n  }\n\n  #readdirMaybePromoteChild(e: Dirent, c: Children): PathBase | undefined {\n    for (let p = c.provisional; p < c.length; p++) {\n      const pchild = c[p]\n      const name = this.nocase\n        ? normalizeNocase(e.name)\n        : normalize(e.name)\n      if (name !== pchild.#matchName) {\n        continue\n      }\n\n      return this.#readdirPromoteChild(e, pchild, p, c)\n    }\n  }\n\n  #readdirPromoteChild(\n    e: Dirent,\n    p: PathBase,\n    index: number,\n    c: Children\n  ): PathBase {\n    const v = p.name\n    // retain any other flags, but set ifmt from dirent\n    p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e)\n    // case sensitivity fixing when we learn the true name.\n    if (v !== e.name) p.name = e.name\n\n    // just advance provisional index (potentially off the list),\n    // otherwise we have to splice/pop it out and re-insert at head\n    if (index !== c.provisional) {\n      if (index === c.length - 1) c.pop()\n      else c.splice(index, 1)\n      c.unshift(p)\n    }\n    c.provisional++\n    return p\n  }\n\n  /**\n   * Call lstat() on this Path, and update all known information that can be\n   * determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(): Promise<PathBase | undefined> {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  /**\n   * synchronous {@link PathBase.lstat}\n   */\n  lstatSync(): PathBase | undefined {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(this.#fs.lstatSync(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  #applyStat(st: Stats) {\n    const {\n      atime,\n      atimeMs,\n      birthtime,\n      birthtimeMs,\n      blksize,\n      blocks,\n      ctime,\n      ctimeMs,\n      dev,\n      gid,\n      ino,\n      mode,\n      mtime,\n      mtimeMs,\n      nlink,\n      rdev,\n      size,\n      uid,\n    } = st\n    this.#atime = atime\n    this.#atimeMs = atimeMs\n    this.#birthtime = birthtime\n    this.#birthtimeMs = birthtimeMs\n    this.#blksize = blksize\n    this.#blocks = blocks\n    this.#ctime = ctime\n    this.#ctimeMs = ctimeMs\n    this.#dev = dev\n    this.#gid = gid\n    this.#ino = ino\n    this.#mode = mode\n    this.#mtime = mtime\n    this.#mtimeMs = mtimeMs\n    this.#nlink = nlink\n    this.#rdev = rdev\n    this.#size = size\n    this.#uid = uid\n    const ifmt = entToType(st)\n    // retain any other flags, but set the ifmt\n    this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED\n    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n      this.#type |= ENOTDIR\n    }\n  }\n\n  #onReaddirCB: ((\n    er: NodeJS.ErrnoException | null,\n    entries: Path[]\n  ) => any)[] = []\n  #readdirCBInFlight: boolean = false\n  #callOnReaddirCB(children: Path[]) {\n    this.#readdirCBInFlight = false\n    const cbs = this.#onReaddirCB.slice()\n    this.#onReaddirCB.length = 0\n    cbs.forEach(cb => cb(null, children))\n  }\n\n  /**\n   * Standard node-style callback interface to get list of directory entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * @param cb The callback called with (er, entries).  Note that the `er`\n   * param is somewhat extraneous, as all readdir() errors are handled and\n   * simply result in an empty set of entries being returned.\n   * @param allowZalgo Boolean indicating that immediately known results should\n   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n   * zalgo at your peril, the dark pony lord is devious and unforgiving.\n   */\n  readdirCB(\n    cb: (er: NodeJS.ErrnoException | null, entries: PathBase[]) => any,\n    allowZalgo: boolean = false\n  ): void {\n    if (!this.canReaddir()) {\n      if (allowZalgo) cb(null, [])\n      else queueMicrotask(() => cb(null, []))\n      return\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      const c = children.slice(0, children.provisional)\n      if (allowZalgo) cb(null, c)\n      else queueMicrotask(() => cb(null, c))\n      return\n    }\n\n    // don't have to worry about zalgo at this point.\n    this.#onReaddirCB.push(cb)\n    if (this.#readdirCBInFlight) {\n      return\n    }\n    this.#readdirCBInFlight = true\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {\n      if (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      } else {\n        // if we didn't get an error, we always get entries.\n        //@ts-ignore\n        for (const e of entries) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      }\n      this.#callOnReaddirCB(children.slice(0, children.provisional))\n      return\n    })\n  }\n\n  #asyncReaddirInFlight?: Promise<void>\n\n  /**\n   * Return an array of known child entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async readdir(): Promise<PathBase[]> {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    if (this.#asyncReaddirInFlight) {\n      await this.#asyncReaddirInFlight\n    } else {\n      /* c8 ignore start */\n      let resolve: () => void = () => {}\n      /* c8 ignore stop */\n      this.#asyncReaddirInFlight = new Promise<void>(\n        res => (resolve = res)\n      )\n      try {\n        for (const e of await this.#fs.promises.readdir(fullpath, {\n          withFileTypes: true,\n        })) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      } catch (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      }\n      this.#asyncReaddirInFlight = undefined\n      resolve()\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * synchronous {@link PathBase.readdir}\n   */\n  readdirSync(): PathBase[] {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    try {\n      for (const e of this.#fs.readdirSync(fullpath, {\n        withFileTypes: true,\n      })) {\n        this.#readdirAddChild(e, children)\n      }\n      this.#readdirSuccess(children)\n    } catch (er) {\n      this.#readdirFail((er as NodeJS.ErrnoException).code)\n      children.provisional = 0\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  canReaddir() {\n    if (this.#type & ENOCHILD) return false\n    const ifmt = IFMT & this.#type\n    // we always set ENOTDIR when setting IFMT, so should be impossible\n    /* c8 ignore start */\n    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n      return false\n    }\n    /* c8 ignore stop */\n    return true\n  }\n\n  shouldWalk(\n    dirs: Set<PathBase | undefined>,\n    walkFilter?: (e: PathBase) => boolean\n  ): boolean {\n    return (\n      (this.#type & IFDIR) === IFDIR &&\n      !(this.#type & ENOCHILD) &&\n      !dirs.has(this) &&\n      (!walkFilter || walkFilter(this))\n    )\n  }\n\n  /**\n   * Return the Path object corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   * On success, returns a Path object.\n   */\n  async realpath(): Promise<PathBase | undefined> {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = await this.#fs.promises.realpath(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Synchronous {@link realpath}\n   */\n  realpathSync(): PathBase | undefined {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = this.#fs.realpathSync(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Internal method to mark this Path object as the scurry cwd,\n   * called by {@link PathScurry#chdir}\n   *\n   * @internal\n   */\n  [setAsCwd](oldCwd: PathBase): void {\n    if (oldCwd === this) return\n\n    const changed = new Set<PathBase>([])\n    let rp = []\n    let p: PathBase = this\n    while (p && p.parent) {\n      changed.add(p)\n      p.#relative = rp.join(this.sep)\n      p.#relativePosix = rp.join('/')\n      p = p.parent\n      rp.push('..')\n    }\n    // now un-memoize parents of old cwd\n    p = oldCwd\n    while (p && p.parent && !changed.has(p)) {\n      p.#relative = undefined\n      p.#relativePosix = undefined\n      p = p.parent\n    }\n  }\n}\n\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nexport class PathWin32 extends PathBase {\n  /**\n   * Separator for generating path strings.\n   */\n  sep: '\\\\' = '\\\\'\n  /**\n   * Separator for parsing path strings.\n   */\n  splitSep: RegExp = eitherSep\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathWin32(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts\n    )\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return win32.parse(path).root\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(rootPath: string): PathBase {\n    rootPath = uncToDrive(rootPath.toUpperCase())\n    if (rootPath === this.root.name) {\n      return this.root\n    }\n    // ok, not that one, check if it matches another we know about\n    for (const [compare, root] of Object.entries(this.roots)) {\n      if (this.sameRoot(rootPath, compare)) {\n        return (this.roots[rootPath] = root)\n      }\n    }\n    // otherwise, have to create a new one.\n    return (this.roots[rootPath] = new PathScurryWin32(\n      rootPath,\n      this\n    ).root)\n  }\n\n  /**\n   * @internal\n   */\n  sameRoot(rootPath: string, compare: string = this.root.name): boolean {\n    // windows can (rarely) have case-sensitive filesystem, but\n    // UNC and drive letters are always case-insensitive, and canonically\n    // represented uppercase.\n    rootPath = rootPath\n      .toUpperCase()\n      .replace(/\\//g, '\\\\')\n      .replace(uncDriveRegexp, '$1\\\\')\n    return rootPath === compare\n  }\n}\n\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nexport class PathPosix extends PathBase {\n  /**\n   * separator for parsing path strings\n   */\n  splitSep: '/' = '/'\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return path.startsWith('/') ? '/' : ''\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(_rootPath: string): PathBase {\n    return this.root\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathPosix(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts\n    )\n  }\n}\n\n/**\n * Options that may be provided to the PathScurry constructor\n */\nexport interface PathScurryOpts {\n  /**\n   * perform case-insensitive path matching. Default based on platform\n   * subclass.\n   */\n  nocase?: boolean\n  /**\n   * Number of Path entries to keep in the cache of Path child references.\n   *\n   * Setting this higher than 65536 will dramatically increase the data\n   * consumption and construction time overhead of each PathScurry.\n   *\n   * Setting this value to 256 or lower will significantly reduce the data\n   * consumption and construction time overhead, but may also reduce resolve()\n   * and readdir() performance on large filesystems.\n   *\n   * Default `16384`.\n   */\n  childrenCacheSize?: number\n  /**\n   * An object that overrides the built-in functions from the fs and\n   * fs/promises modules.\n   *\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nexport abstract class PathScurryBase {\n  /**\n   * The root Path entry for the current working directory of this Scurry\n   */\n  root: PathBase\n  /**\n   * The string path for the root of this Scurry's current working directory\n   */\n  rootPath: string\n  /**\n   * A collection of all roots encountered, referenced by rootPath\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * The Path entry corresponding to this PathScurry's current working directory.\n   */\n  cwd: PathBase\n  #resolveCache: ResolveCache\n  #resolvePosixCache: ResolveCache\n  #children: ChildrenCache\n  /**\n   * Perform path comparisons case-insensitively.\n   *\n   * Defaults true on Darwin and Windows systems, false elsewhere.\n   */\n  nocase: boolean\n\n  /**\n   * The path separator used for parsing paths\n   *\n   * `'/'` on Posix systems, either `'/'` or `'\\\\'` on Windows\n   */\n  abstract sep: string | RegExp\n\n  #fs: FSValue\n\n  /**\n   * This class should not be instantiated directly.\n   *\n   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n   *\n   * @internal\n   */\n  constructor(\n    cwd: URL | string = process.cwd(),\n    pathImpl: typeof win32 | typeof posix,\n    sep: string | RegExp,\n    {\n      nocase,\n      childrenCacheSize = 16 * 1024,\n      fs = defaultFS,\n    }: PathScurryOpts = {}\n  ) {\n    this.#fs = fsFromOption(fs)\n    if (cwd instanceof URL || cwd.startsWith('file://')) {\n      cwd = fileURLToPath(cwd)\n    }\n    // resolve and split root, and then add to the store.\n    // this is the only time we call path.resolve()\n    const cwdPath = pathImpl.resolve(cwd)\n    this.roots = Object.create(null)\n    this.rootPath = this.parseRootPath(cwdPath)\n    this.#resolveCache = new ResolveCache()\n    this.#resolvePosixCache = new ResolveCache()\n    this.#children = new ChildrenCache(childrenCacheSize)\n\n    const split = cwdPath.substring(this.rootPath.length).split(sep)\n    // resolve('/') leaves '', splits to [''], we don't want that.\n    if (split.length === 1 && !split[0]) {\n      split.pop()\n    }\n    /* c8 ignore start */\n    if (nocase === undefined) {\n      throw new TypeError(\n        'must provide nocase setting to PathScurryBase ctor'\n      )\n    }\n    /* c8 ignore stop */\n    this.nocase = nocase\n    this.root = this.newRoot(this.#fs)\n    this.roots[this.rootPath] = this.root\n    let prev: PathBase = this.root\n    let len = split.length - 1\n    const joinSep = pathImpl.sep\n    let abs = this.rootPath\n    let sawFirst = false\n    for (const part of split) {\n      const l = len--\n      prev = prev.child(part, {\n        relative: new Array(l).fill('..').join(joinSep),\n        relativePosix: new Array(l).fill('..').join('/'),\n        fullpath: (abs += (sawFirst ? '' : joinSep) + part),\n      })\n      sawFirst = true\n    }\n    this.cwd = prev\n  }\n\n  /**\n   * Get the depth of a provided path, string, or the cwd\n   */\n  depth(path: Path | string = this.cwd): number {\n    if (typeof path === 'string') {\n      path = this.cwd.resolve(path)\n    }\n    return path.depth()\n  }\n\n  /**\n   * Parse the root portion of a path string\n   *\n   * @internal\n   */\n  abstract parseRootPath(dir: string): string\n  /**\n   * create a new Path to use as root during construction.\n   *\n   * @internal\n   */\n  abstract newRoot(fs: FSValue): PathBase\n  /**\n   * Determine whether a given path string is absolute\n   */\n  abstract isAbsolute(p: string): boolean\n\n  /**\n   * Return the cache of child entries.  Exposed so subclasses can create\n   * child Path objects in a platform-specific way.\n   *\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolve(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolveCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpath()\n    this.#resolveCache.set(r, result)\n    return result\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string, returning\n   * the posix path.  Identical to .resolve() on posix systems, but on\n   * windows will return a forward-slash separated UNC path.\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolvePosix(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolvePosixCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpathPosix()\n    this.#resolvePosixCache.set(r, result)\n    return result\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or entry\n   */\n  relative(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relative()\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or\n   * entry, using / as the path delimiter, even on Windows.\n   */\n  relativePosix(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relativePosix()\n  }\n\n  /**\n   * Return the basename for the provided string or Path object\n   */\n  basename(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.name\n  }\n\n  /**\n   * Return the dirname for the provided string or Path object\n   */\n  dirname(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return (entry.parent || entry).fullpath()\n  }\n\n  /**\n   * Return an array of known child entries.\n   *\n   * First argument may be either a string, or a Path object.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * Unlike `fs.readdir()`, the `withFileTypes` option defaults to `true`. Set\n   * `{ withFileTypes: false }` to return strings.\n   */\n\n  readdir(): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: true }): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: false }): Promise<string[]>\n  readdir(opts: { withFileTypes: boolean }): Promise<PathBase[] | string[]>\n  readdir(entry: PathBase | string): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: true }\n  ): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: false }\n  ): Promise<string[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean }\n  ): Promise<PathBase[] | string[]>\n  async readdir(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    }\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else {\n      const p = await entry.readdir()\n      return withFileTypes ? p : p.map(e => e.name)\n    }\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readdir}\n   */\n  readdirSync(): PathBase[]\n  readdirSync(opts: { withFileTypes: true }): PathBase[]\n  readdirSync(opts: { withFileTypes: false }): string[]\n  readdirSync(opts: { withFileTypes: boolean }): PathBase[] | string[]\n  readdirSync(entry: PathBase | string): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: true }\n  ): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: false }\n  ): string[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean }\n  ): PathBase[] | string[]\n  readdirSync(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    }\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes = true } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else if (withFileTypes) {\n      return entry.readdirSync()\n    } else {\n      return entry.readdirSync().map(e => e.name)\n    }\n  }\n\n  /**\n   * Call lstat() on the string or Path object, and update all known\n   * information that can be determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(\n    entry: string | PathBase = this.cwd\n  ): Promise<PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstat()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.lstat}\n   */\n  lstatSync(entry: string | PathBase = this.cwd): PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstatSync()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to the target of a\n   * symbolic link.\n   *\n   * If the path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  readlink(): Promise<string | undefined>\n  readlink(opt: { withFileTypes: false }): Promise<string | undefined>\n  readlink(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  readlink(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): Promise<string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): Promise<PathBase | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): Promise<string | PathBase | undefined>\n  async readlink(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.readlink()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readlink}\n   */\n  readlinkSync(): string | undefined\n  readlinkSync(opt: { withFileTypes: false }): string | undefined\n  readlinkSync(opt: { withFileTypes: true }): PathBase | undefined\n  readlinkSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): string | PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.readlinkSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  realpath(): Promise<string | undefined>\n  realpath(opt: { withFileTypes: false }): Promise<string | undefined>\n  realpath(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  realpath(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): Promise<string | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): Promise<PathBase | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): Promise<string | PathBase | undefined>\n  async realpath(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.realpath()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  realpathSync(): string | undefined\n  realpathSync(opt: { withFileTypes: false }): string | undefined\n  realpathSync(opt: { withFileTypes: true }): PathBase | undefined\n  realpathSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false }\n  ): string | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true }\n  ): PathBase | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean }\n  ): string | PathBase | undefined\n  realpathSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    }\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.realpathSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Asynchronously walk the directory tree, returning an array of\n   * all path strings or Path objects found.\n   *\n   * Note that this will be extremely memory-hungry on large filesystems.\n   * In such cases, it may be better to use the stream or async iterator\n   * walk implementation.\n   */\n  walk(): Promise<PathBase[]>\n  walk(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Promise<PathBase[]>\n  walk(opts: WalkOptionsWithFileTypesFalse): Promise<string[]>\n  walk(opts: WalkOptions): Promise<string[] | PathBase[]>\n  walk(entry: string | PathBase): Promise<PathBase[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Promise<PathBase[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Promise<string[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Promise<PathBase[] | string[]>\n  async walk(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results: (string | PathBase)[] = []\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const walk = (\n      dir: PathBase,\n      cb: (er?: NodeJS.ErrnoException) => void\n    ) => {\n      dirs.add(dir)\n      dir.readdirCB((er, entries) => {\n        /* c8 ignore start */\n        if (er) {\n          return cb(er)\n        }\n        /* c8 ignore stop */\n        let len = entries.length\n        if (!len) return cb()\n        const next = () => {\n          if (--len === 0) {\n            cb()\n          }\n        }\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            results.push(withFileTypes ? e : e.fullpath())\n          }\n          if (follow && e.isSymbolicLink()) {\n            e.realpath()\n              .then(r => (r?.isUnknown() ? r.lstat() : r))\n              .then(r =>\n                r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next()\n              )\n          } else {\n            if (e.shouldWalk(dirs, walkFilter)) {\n              walk(e, next)\n            } else {\n              next()\n            }\n          }\n        }\n      }, true) // zalgooooooo\n    }\n\n    const start = entry\n    return new Promise<PathBase[] | string[]>((res, rej) => {\n      walk(start, er => {\n        /* c8 ignore start */\n        if (er) return rej(er)\n        /* c8 ignore stop */\n        res(results as PathBase[] | string[])\n      })\n    })\n  }\n\n  /**\n   * Synchronously walk the directory tree, returning an array of\n   * all path strings or Path objects found.\n   *\n   * Note that this will be extremely memory-hungry on large filesystems.\n   * In such cases, it may be better to use the stream or async iterator\n   * walk implementation.\n   */\n  walkSync(): PathBase[]\n  walkSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): PathBase[]\n  walkSync(opts: WalkOptionsWithFileTypesFalse): string[]\n  walkSync(opts: WalkOptions): string[] | PathBase[]\n  walkSync(entry: string | PathBase): PathBase[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue\n  ): PathBase[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): string[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): PathBase[] | string[]\n  walkSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results: (string | PathBase)[] = []\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          results.push(withFileTypes ? e : e.fullpath())\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n    return results as string[] | PathBase[]\n  }\n\n  /**\n   * Support for `for await`\n   *\n   * Alias for {@link PathScurryBase.iterate}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  [Symbol.asyncIterator]() {\n    return this.iterate()\n  }\n\n  /**\n   * Async generator form of {@link PathScurryBase.walk}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking, especially if most/all of the directory tree has been previously\n   * walked.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  iterate(): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesFalse\n  ): AsyncGenerator<string, void, void>\n  iterate(opts: WalkOptions): AsyncGenerator<string | PathBase, void, void>\n  iterate(entry: string | PathBase): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): AsyncGenerator<string, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): AsyncGenerator<PathBase | string, void, void>\n  iterate(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    options: WalkOptions = {}\n  ): AsyncGenerator<PathBase | string, void, void> {\n    // iterating async over the stream is significantly more performant,\n    // especially in the warm-cache scenario, because it buffers up directory\n    // entries in the background instead of waiting for a yield for each one.\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      options = entry\n      entry = this.cwd\n    }\n    return this.stream(entry, options)[Symbol.asyncIterator]()\n  }\n\n  /**\n   * Iterating over a PathScurry performs a synchronous walk.\n   *\n   * Alias for {@link PathScurryBase.iterateSync}\n   */\n  [Symbol.iterator]() {\n    return this.iterateSync()\n  }\n\n  iterateSync(): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesFalse\n  ): Generator<string, void, void>\n  iterateSync(opts: WalkOptions): Generator<string | PathBase, void, void>\n  iterateSync(entry: string | PathBase): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Generator<string, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Generator<PathBase | string, void, void>\n  *iterateSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Generator<PathBase | string, void, void> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    if (!filter || filter(entry)) {\n      yield withFileTypes ? entry : entry.fullpath()\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          yield withFileTypes ? e : e.fullpath()\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n  }\n\n  /**\n   * Stream form of {@link PathScurryBase.walk}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   */\n  stream(): Minipass<PathBase>\n  stream(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Minipass<PathBase>\n  stream(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  stream(opts: WalkOptions): Minipass<string | PathBase>\n  stream(entry: string | PathBase): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue\n  ): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Minipass<string>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Minipass<string> | Minipass<PathBase>\n  stream(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n\n        processing++\n        dirs.add(dir)\n\n        const onReaddir = (\n          er: null | NodeJS.ErrnoException,\n          entries: PathBase[],\n          didRealpaths: boolean = false\n        ) => {\n          /* c8 ignore start */\n          if (er) return results.emit('error', er)\n          /* c8 ignore stop */\n          if (follow && !didRealpaths) {\n            const promises: Promise<PathBase | undefined>[] = []\n            for (const e of entries) {\n              if (e.isSymbolicLink()) {\n                promises.push(\n                  e\n                    .realpath()\n                    .then((r: PathBase | undefined) =>\n                      r?.isUnknown() ? r.lstat() : r\n                    )\n                )\n              }\n            }\n            if (promises.length) {\n              Promise.all(promises).then(() =>\n                onReaddir(null, entries, true)\n              )\n              return\n            }\n          }\n\n          for (const e of entries) {\n            if (e && (!filter || filter(e))) {\n              if (!results.write(withFileTypes ? e : e.fullpath())) {\n                paused = true\n              }\n            }\n          }\n\n          processing--\n          for (const e of entries) {\n            const r = e.realpathCached() || e\n            if (r.shouldWalk(dirs, walkFilter)) {\n              queue.push(r)\n            }\n          }\n          if (paused && !results.flowing) {\n            results.once('drain', process)\n          } else if (!sync) {\n            process()\n          }\n        }\n\n        // zalgo containment\n        let sync = true\n        dir.readdirCB(onReaddir, true)\n        sync = false\n      }\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  /**\n   * Synchronous form of {@link PathScurryBase.stream}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   *\n   * Will complete the walk in a single tick if the stream is consumed fully.\n   * Otherwise, will pause as needed for stream backpressure.\n   */\n  streamSync(): Minipass<PathBase>\n  streamSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset\n  ): Minipass<PathBase>\n  streamSync(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  streamSync(opts: WalkOptions): Minipass<string | PathBase>\n  streamSync(entry: string | PathBase): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue\n  ): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse\n  ): Minipass<string>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptions\n  ): Minipass<string> | Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {}\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    const dirs = new Set<PathBase>()\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n        processing++\n        dirs.add(dir)\n\n        const entries = dir.readdirSync()\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            if (!results.write(withFileTypes ? e : e.fullpath())) {\n              paused = true\n            }\n          }\n        }\n        processing--\n        for (const e of entries) {\n          let r: PathBase | undefined = e\n          if (e.isSymbolicLink()) {\n            if (!(follow && (r = e.realpathSync()))) continue\n            if (r.isUnknown()) r.lstatSync()\n          }\n          if (r.shouldWalk(dirs, walkFilter)) {\n            queue.push(r)\n          }\n        }\n      }\n      if (paused && !results.flowing) results.once('drain', process)\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  chdir(path: string | Path = this.cwd) {\n    const oldCwd = this.cwd\n    this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path\n    this.cwd[setAsCwd](oldCwd)\n  }\n}\n\n/**\n * Options provided to all walk methods.\n */\nexport interface WalkOptions {\n  /**\n   * Return results as {@link PathBase} objects rather than strings.\n   * When set to false, results are fully resolved paths, as returned by\n   * {@link PathBase.fullpath}.\n   * @default true\n   */\n  withFileTypes?: boolean\n\n  /**\n   *  Attempt to read directory entries from symbolic links. Otherwise, only\n   *  actual directories are traversed. Regardless of this setting, a given\n   *  target path will only ever be walked once, meaning that a symbolic link\n   *  to a previously traversed directory will never be followed.\n   *\n   *  Setting this imposes a slight performance penalty, because `readlink`\n   *  must be called on all symbolic links encountered, in order to avoid\n   *  infinite cycles.\n   * @default false\n   */\n  follow?: boolean\n\n  /**\n   * Only return entries where the provided function returns true.\n   *\n   * This will not prevent directories from being traversed, even if they do\n   * not pass the filter, though it will prevent directories themselves from\n   * being included in the result set.  See {@link walkFilter}\n   *\n   * Asynchronous functions are not supported here.\n   *\n   * By default, if no filter is provided, all entries and traversed\n   * directories are included.\n   */\n  filter?: (entry: PathBase) => boolean\n\n  /**\n   * Only traverse directories (and in the case of {@link follow} being set to\n   * true, symbolic links to directories) if the provided function returns\n   * true.\n   *\n   * This will not prevent directories from being included in the result set,\n   * even if they do not pass the supplied filter function.  See {@link filter}\n   * to do that.\n   *\n   * Asynchronous functions are not supported here.\n   */\n  walkFilter?: (entry: PathBase) => boolean\n}\n\nexport type WalkOptionsWithFileTypesUnset = WalkOptions & {\n  withFileTypes?: undefined\n}\nexport type WalkOptionsWithFileTypesTrue = WalkOptions & {\n  withFileTypes: true\n}\nexport type WalkOptionsWithFileTypesFalse = WalkOptions & {\n  withFileTypes: false\n}\n\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nexport class PathScurryWin32 extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep: '\\\\' = '\\\\'\n\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {}\n  ) {\n    const { nocase = true } = opts\n    super(cwd, win32, '\\\\', { ...opts, nocase })\n    this.nocase = nocase\n    for (let p: PathBase | undefined = this.cwd; p; p = p.parent) {\n      p.nocase = this.nocase\n    }\n  }\n\n  /**\n   * @internal\n   */\n  parseRootPath(dir: string): string {\n    // if the path starts with a single separator, it's not a UNC, and we'll\n    // just get separator as the root, and driveFromUNC will return \\\n    // In that case, mount \\ on the root from the cwd.\n    return win32.parse(dir).root.toUpperCase()\n  }\n\n  /**\n   * @internal\n   */\n  newRoot(fs: FSValue) {\n    return new PathWin32(\n      this.rootPath,\n      IFDIR,\n      undefined,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      { fs }\n    )\n  }\n\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p: string): boolean {\n    return (\n      p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p)\n    )\n  }\n}\n\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryPosix extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {}\n  ) {\n    const { nocase = false } = opts\n    super(cwd, posix, '/', { ...opts, nocase })\n    this.nocase = nocase\n  }\n\n  /**\n   * @internal\n   */\n  parseRootPath(_dir: string): string {\n    return '/'\n  }\n\n  /**\n   * @internal\n   */\n  newRoot(fs: FSValue) {\n    return new PathPosix(\n      this.rootPath,\n      IFDIR,\n      undefined,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      { fs }\n    )\n  }\n\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p: string): boolean {\n    return p.startsWith('/')\n  }\n}\n\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryDarwin extends PathScurryPosix {\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {}\n  ) {\n    const { nocase = true } = opts\n    super(cwd, { ...opts, nocase })\n  }\n}\n\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexport const Path = process.platform === 'win32' ? PathWin32 : PathPosix\nexport type Path = PathBase | InstanceType<typeof Path>\n\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexport const PathScurry:\n  | typeof PathScurryWin32\n  | typeof PathScurryDarwin\n  | typeof PathScurryPosix =\n  process.platform === 'win32'\n    ? PathScurryWin32\n    : process.platform === 'darwin'\n    ? PathScurryDarwin\n    : PathScurryPosix\nexport type PathScurry = PathScurryBase | InstanceType<typeof PathScurry>\n","const proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nimport { EventEmitter } from 'events'\nimport Stream from 'stream'\nimport { StringDecoder } from 'string_decoder'\n\n/**\n * Same as StringDecoder, but exposing the `lastNeed` flag on the type\n */\ntype SD = StringDecoder & { lastNeed: boolean }\n\nexport type { SD, Pipe, PipeProxyErrors }\n\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nexport const isStream = (\n  s: any\n): s is Minipass.Readable | Minipass.Writable =>\n  !!s &&\n  typeof s === 'object' &&\n  (s instanceof Minipass ||\n    s instanceof Stream ||\n    isReadable(s) ||\n    isWritable(s))\n\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nexport const isReadable = (s: any): s is Minipass.Readable =>\n  !!s &&\n  typeof s === 'object' &&\n  s instanceof EventEmitter &&\n  typeof (s as Minipass.Readable).pipe === 'function' &&\n  // node core Writable streams have a pipe() method, but it throws\n  (s as Minipass.Readable).pipe !== Stream.Writable.prototype.pipe\n\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nexport const isWritable = (s: any): s is Minipass.Readable =>\n  !!s &&\n  typeof s === 'object' &&\n  s instanceof EventEmitter &&\n  typeof (s as Minipass.Writable).write === 'function' &&\n  typeof (s as Minipass.Writable).end === 'function'\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\nconst DATALISTENERS = Symbol('dataListeners')\nconst DISCARDED = Symbol('discarded')\n\nconst defer = (fn: (...a: any[]) => any) => Promise.resolve().then(fn)\nconst nodefer = (fn: (...a: any[]) => any) => fn()\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\ntype EndishEvent = 'end' | 'finish' | 'prefinish'\nconst isEndish = (ev: any): ev is EndishEvent =>\n  ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBufferLike = (b: any): b is ArrayBufferLike =>\n  b instanceof ArrayBuffer ||\n  (!!b &&\n    typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = (b: any): b is ArrayBufferView =>\n  !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\n/**\n * Options that may be passed to stream.pipe()\n */\nexport interface PipeOptions {\n  /**\n   * end the destination stream when the source stream ends\n   */\n  end?: boolean\n  /**\n   * proxy errors from the source stream to the destination stream\n   */\n  proxyErrors?: boolean\n}\n\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe<T extends unknown> {\n  src: Minipass<T>\n  dest: Minipass<any, T>\n  opts: PipeOptions\n  ondrain: () => any\n  constructor(\n    src: Minipass<T>,\n    dest: Minipass.Writable,\n    opts: PipeOptions\n  ) {\n    this.src = src\n    this.dest = dest as Minipass<any, T>\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    this.dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // only here for the prototype\n  /* c8 ignore start */\n  proxyErrors(_er: any) {}\n  /* c8 ignore stop */\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors<T> extends Pipe<T> {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(\n    src: Minipass<T>,\n    dest: Minipass.Writable,\n    opts: PipeOptions\n  ) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nexport namespace Minipass {\n  /**\n   * Encoding used to create a stream that outputs strings rather than\n   * Buffer objects.\n   */\n  export type Encoding = BufferEncoding | 'buffer' | null\n\n  /**\n   * Any stream that Minipass can pipe into\n   */\n  export type Writable =\n    | Minipass<any, any, any>\n    | NodeJS.WriteStream\n    | (NodeJS.WriteStream & { fd: number })\n    | (EventEmitter & {\n        end(): any\n        write(chunk: any, ...args: any[]): any\n      })\n\n  /**\n   * Any stream that can be read from\n   */\n  export type Readable =\n    | Minipass<any, any, any>\n    | NodeJS.ReadStream\n    | (NodeJS.ReadStream & { fd: number })\n    | (EventEmitter & {\n        pause(): any\n        resume(): any\n        pipe(...destArgs: any[]): any\n      })\n\n  /**\n   * Utility type that can be iterated sync or async\n   */\n  export type DualIterable<T> = Iterable<T> & AsyncIterable<T>\n\n  type EventArguments = Record<string | symbol, unknown[]>\n\n  /**\n   * The listing of events that a Minipass class can emit.\n   * Extend this when extending the Minipass class, and pass as\n   * the third template argument.  The key is the name of the event,\n   * and the value is the argument list.\n   *\n   * Any undeclared events will still be allowed, but the handler will get\n   * arguments as `unknown[]`.\n   */\n  export interface Events<RType extends any = Buffer>\n    extends EventArguments {\n    readable: []\n    data: [chunk: RType]\n    error: [er: unknown]\n    abort: [reason: unknown]\n    drain: []\n    resume: []\n    end: []\n    finish: []\n    prefinish: []\n    close: []\n    [DESTROYED]: [er?: unknown]\n    [ERROR]: [er: unknown]\n  }\n\n  /**\n   * String or buffer-like data that can be joined and sliced\n   */\n  export type ContiguousData =\n    | Buffer\n    | ArrayBufferLike\n    | ArrayBufferView\n    | string\n  export type BufferOrString = Buffer | string\n\n  /**\n   * Options passed to the Minipass constructor.\n   */\n  export type SharedOptions = {\n    /**\n     * Defer all data emission and other events until the end of the\n     * current tick, similar to Node core streams\n     */\n    async?: boolean\n    /**\n     * A signal which will abort the stream\n     */\n    signal?: AbortSignal\n    /**\n     * Output string encoding. Set to `null` or `'buffer'` (or omit) to\n     * emit Buffer objects rather than strings.\n     *\n     * Conflicts with `objectMode`\n     */\n    encoding?: BufferEncoding | null | 'buffer'\n    /**\n     * Output data exactly as it was written, supporting non-buffer/string\n     * data (such as arbitrary objects, falsey values, etc.)\n     *\n     * Conflicts with `encoding`\n     */\n    objectMode?: boolean\n  }\n\n  /**\n   * Options for a string encoded output\n   */\n  export type EncodingOptions = SharedOptions & {\n    encoding: BufferEncoding\n    objectMode?: false\n  }\n\n  /**\n   * Options for contiguous data buffer output\n   */\n  export type BufferOptions = SharedOptions & {\n    encoding?: null | 'buffer'\n    objectMode?: false\n  }\n\n  /**\n   * Options for objectMode arbitrary output\n   */\n  export type ObjectModeOptions = SharedOptions & {\n    objectMode: true\n    encoding?: null\n  }\n\n  /**\n   * Utility type to determine allowed options based on read type\n   */\n  export type Options<T> = T extends string\n    ? EncodingOptions | ObjectModeOptions\n    : T extends Buffer\n    ? BufferOptions | ObjectModeOptions\n    : SharedOptions\n}\n\nconst isObjectModeOptions = (\n  o: Minipass.SharedOptions\n): o is Minipass.ObjectModeOptions => !!o.objectMode\n\nconst isEncodingOptions = (\n  o: Minipass.SharedOptions\n): o is Minipass.EncodingOptions =>\n  !o.objectMode && !!o.encoding && o.encoding !== 'buffer'\n\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nexport class Minipass<\n    RType extends unknown = Buffer,\n    WType extends unknown = RType extends Minipass.BufferOrString\n      ? Minipass.ContiguousData\n      : RType,\n    Events extends Minipass.Events<RType> = Minipass.Events<RType>\n  >\n  extends EventEmitter\n  implements Minipass.DualIterable<RType>\n{\n  [FLOWING]: boolean = false;\n  [PAUSED]: boolean = false;\n  [PIPES]: Pipe<RType>[] = [];\n  [BUFFER]: RType[] = [];\n  [OBJECTMODE]: boolean;\n  [ENCODING]: BufferEncoding | null;\n  [ASYNC]: boolean;\n  [DECODER]: SD | null;\n  [EOF]: boolean = false;\n  [EMITTED_END]: boolean = false;\n  [EMITTING_END]: boolean = false;\n  [CLOSED]: boolean = false;\n  [EMITTED_ERROR]: unknown = null;\n  [BUFFERLENGTH]: number = 0;\n  [DESTROYED]: boolean = false;\n  [SIGNAL]?: AbortSignal;\n  [ABORTED]: boolean = false;\n  [DATALISTENERS]: number = 0;\n  [DISCARDED]: boolean = false\n\n  /**\n   * true if the stream can be written\n   */\n  writable: boolean = true\n  /**\n   * true if the stream can be read\n   */\n  readable: boolean = true\n\n  /**\n   * If `RType` is Buffer, then options do not need to be provided.\n   * Otherwise, an options object must be provided to specify either\n   * {@link Minipass.SharedOptions.objectMode} or\n   * {@link Minipass.SharedOptions.encoding}, as appropriate.\n   */\n  constructor(\n    ...args: RType extends Buffer\n      ? [] | [Minipass.Options<RType>]\n      : [Minipass.Options<RType>]\n  ) {\n    const options: Minipass.Options<RType> = (args[0] ||\n      {}) as Minipass.Options<RType>\n    super()\n    if (options.objectMode && typeof options.encoding === 'string') {\n      throw new TypeError(\n        'Encoding and objectMode may not be used together'\n      )\n    }\n    if (isObjectModeOptions(options)) {\n      this[OBJECTMODE] = true\n      this[ENCODING] = null\n    } else if (isEncodingOptions(options)) {\n      this[ENCODING] = options.encoding\n      this[OBJECTMODE] = false\n    } else {\n      this[OBJECTMODE] = false\n      this[ENCODING] = null\n    }\n    this[ASYNC] = !!options.async\n    this[DECODER] = this[ENCODING]\n      ? (new StringDecoder(this[ENCODING]) as SD)\n      : null\n\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n\n    const { signal } = options\n    if (signal) {\n      this[SIGNAL] = signal\n      if (signal.aborted) {\n        this[ABORT]()\n      } else {\n        signal.addEventListener('abort', () => this[ABORT]())\n      }\n    }\n  }\n\n  /**\n   * The amount of data stored in the buffer waiting to be read.\n   *\n   * For Buffer strings, this will be the total byte length.\n   * For string encoding streams, this will be the string character length,\n   * according to JavaScript's `string.length` logic.\n   * For objectMode streams, this is a count of the items waiting to be\n   * emitted.\n   */\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  /**\n   * The `BufferEncoding` currently in use, or `null`\n   */\n  get encoding() {\n    return this[ENCODING]\n  }\n\n  /**\n   * @deprecated - This is a read only property\n   */\n  set encoding(_enc) {\n    throw new Error('Encoding must be set at instantiation time')\n  }\n\n  /**\n   * @deprecated - Encoding may only be set at instantiation time\n   */\n  setEncoding(_enc: Minipass.Encoding) {\n    throw new Error('Encoding must be set at instantiation time')\n  }\n\n  /**\n   * True if this is an objectMode stream\n   */\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n\n  /**\n   * @deprecated - This is a read-only property\n   */\n  set objectMode(_om) {\n    throw new Error('objectMode must be set at instantiation time')\n  }\n\n  /**\n   * true if this is an async stream\n   */\n  get ['async'](): boolean {\n    return this[ASYNC]\n  }\n  /**\n   * Set to true to make this stream async.\n   *\n   * Once set, it cannot be unset, as this would potentially cause incorrect\n   * behavior.  Ie, a sync stream can be made async, but an async stream\n   * cannot be safely made sync.\n   */\n  set ['async'](a: boolean) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    this.emit('abort', this[SIGNAL]?.reason)\n    this.destroy(this[SIGNAL]?.reason)\n  }\n\n  /**\n   * True if the stream has been aborted.\n   */\n  get aborted() {\n    return this[ABORTED]\n  }\n  /**\n   * No-op setter. Stream aborted status is set via the AbortSignal provided\n   * in the constructor options.\n   */\n  set aborted(_) {}\n\n  /**\n   * Write data into the stream\n   *\n   * If the chunk written is a string, and encoding is not specified, then\n   * `utf8` will be assumed. If the stream encoding matches the encoding of\n   * a written string, and the state of the string decoder allows it, then\n   * the string will be passed through to either the output or the internal\n   * buffer without any processing. Otherwise, it will be turned into a\n   * Buffer object for processing into the desired encoding.\n   *\n   * If provided, `cb` function is called immediately before return for\n   * sync streams, or on next tick for async streams, because for this\n   * base class, a chunk is considered \"processed\" once it is accepted\n   * and either emitted or buffered. That is, the callback does not indicate\n   * that the chunk has been eventually emitted, though of course child\n   * classes can override this function to do whatever processing is required\n   * and call `super.write(...)` only once processing is completed.\n   */\n  write(chunk: WType, cb?: () => void): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding,\n    cb?: () => void\n  ): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ): boolean {\n    if (this[ABORTED]) return false\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = 'utf8'\n    }\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : nodefer\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything is only allowed if in object mode, so throw\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(\n          chunk.buffer,\n          chunk.byteOffset,\n          chunk.byteLength\n        )\n      } else if (isArrayBufferLike(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(chunk)\n      } else if (typeof chunk !== 'string') {\n        throw new Error(\n          'Non-contiguous data written to non-objectMode stream'\n        )\n      }\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      // maybe impossible?\n      /* c8 ignore start */\n      if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n      /* c8 ignore stop */\n\n      if (this[FLOWING]) this.emit('data', chunk as unknown as RType)\n      else this[BUFFERPUSH](chunk as unknown as RType)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this[FLOWING]\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!(chunk as Minipass.BufferOrString).length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this[FLOWING]\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)\n    ) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = this[DECODER].write(chunk)\n    }\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this[FLOWING]) this.emit('data', chunk as unknown as RType)\n    else this[BUFFERPUSH](chunk as unknown as RType)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this[FLOWING]\n  }\n\n  /**\n   * Low-level explicit read method.\n   *\n   * In objectMode, the argument is ignored, and one item is returned if\n   * available.\n   *\n   * `n` is the number of bytes (or in the case of encoding streams,\n   * characters) to consume. If `n` is not provided, then the entire buffer\n   * is returned, or `null` is returned if no data is available.\n   *\n   * If `n` is greater that the amount of data in the internal buffer,\n   * then `null` is returned.\n   */\n  read(n?: number | null): RType | null {\n    if (this[DESTROYED]) return null\n    this[DISCARDED] = false\n\n    if (\n      this[BUFFERLENGTH] === 0 ||\n      n === 0 ||\n      (n && n > this[BUFFERLENGTH])\n    ) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      // not object mode, so if we have an encoding, then RType is string\n      // otherwise, must be Buffer\n      this[BUFFER] = [\n        (this[ENCODING]\n          ? this[BUFFER].join('')\n          : Buffer.concat(\n              this[BUFFER] as Buffer[],\n              this[BUFFERLENGTH]\n            )) as RType,\n      ]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0] as RType)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n: number | null, chunk: RType) {\n    if (this[OBJECTMODE]) this[BUFFERSHIFT]()\n    else {\n      const c = chunk as Minipass.BufferOrString\n      if (n === c.length || n === null) this[BUFFERSHIFT]()\n      else if (typeof c === 'string') {\n        this[BUFFER][0] = c.slice(n) as RType\n        chunk = c.slice(0, n) as RType\n        this[BUFFERLENGTH] -= n\n      } else {\n        this[BUFFER][0] = c.subarray(n) as RType\n        chunk = c.subarray(0, n) as RType\n        this[BUFFERLENGTH] -= n\n      }\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  /**\n   * End the stream, optionally providing a final write.\n   *\n   * See {@link Minipass#write} for argument descriptions\n   */\n  end(cb?: () => void): this\n  end(chunk: WType, cb?: () => void): this\n  end(chunk: WType, encoding?: Minipass.Encoding, cb?: () => void): this\n  end(\n    chunk?: WType | (() => void),\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ) {\n    if (typeof chunk === 'function') {\n      cb = chunk as () => void\n      chunk = undefined\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = 'utf8'\n    }\n    if (chunk !== undefined) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this[FLOWING] || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    if (!this[DATALISTENERS] && !this[PIPES].length) {\n      this[DISCARDED] = true\n    }\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  /**\n   * Resume the stream if it is currently in a paused state\n   *\n   * If called when there are no pipe destinations or `data` event listeners,\n   * this will place the stream in a \"discarded\" state, where all data will\n   * be thrown away. The discarded state is removed if a pipe destination or\n   * data handler is added, if pause() is called, or if any synchronous or\n   * asynchronous iteration is started.\n   */\n  resume() {\n    return this[RESUME]()\n  }\n\n  /**\n   * Pause the stream\n   */\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n    this[DISCARDED] = false\n  }\n\n  /**\n   * true if the stream has been forcibly destroyed\n   */\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  /**\n   * true if the stream is currently in a flowing state, meaning that\n   * any writes will be immediately emitted.\n   */\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  /**\n   * true if the stream is currently in a paused state\n   */\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk: RType) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += (chunk as Minipass.BufferOrString).length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT](): RType {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n    else\n      this[BUFFERLENGTH] -= (\n        this[BUFFER][0] as Minipass.BufferOrString\n      ).length\n    return this[BUFFER].shift() as RType\n  }\n\n  [FLUSH](noDrain: boolean = false) {\n    do {} while (\n      this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n      this[BUFFER].length\n    )\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk: RType) {\n    this.emit('data', chunk)\n    return this[FLOWING]\n  }\n\n  /**\n   * Pipe all data emitted by this stream into the destination provided.\n   *\n   * Triggers the flow of data.\n   */\n  pipe<W extends Minipass.Writable>(dest: W, opts?: PipeOptions): W {\n    if (this[DESTROYED]) return dest\n    this[DISCARDED] = false\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      // \"as\" here just ignores the WType, which pipes don't care about,\n      // since they're only consuming from us, and writing to the dest\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe<RType>(this as Minipass<RType>, dest, opts)\n          : new PipeProxyErrors<RType>(this as Minipass<RType>, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  /**\n   * Fully unhook a piped destination stream.\n   *\n   * If the destination stream was the only consumer of this stream (ie,\n   * there are no other piped destinations or `'data'` event listeners)\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  unpipe<W extends Minipass.Writable>(dest: W) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      if (this[PIPES].length === 1) {\n        if (this[FLOWING] && this[DATALISTENERS] === 0) {\n          this[FLOWING] = false\n        }\n        this[PIPES] = []\n      } else this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  /**\n   * Alias for {@link Minipass#on}\n   */\n  addListener<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ): this {\n    return this.on(ev, handler)\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.on`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * - Adding a 'data' event handler will trigger the flow of data\n   *\n   * - Adding a 'readable' event handler when there is data waiting to be read\n   *   will cause 'readable' to be emitted immediately.\n   *\n   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n   *   already passed will cause the event to be emitted immediately and all\n   *   handlers removed.\n   *\n   * - Adding an 'error' event handler after an error has been emitted will\n   *   cause the event to be re-emitted immediately with the error previously\n   *   raised.\n   */\n  on<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ): this {\n    const ret = super.on(\n      ev as string | symbol,\n      handler as (...a: any[]) => any\n    )\n    if (ev === 'data') {\n      this[DISCARDED] = false\n      this[DATALISTENERS]++\n      if (!this[PIPES].length && !this[FLOWING]) {\n        this[RESUME]()\n      }\n    } else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n      super.emit('readable')\n    } else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      const h = handler as (...a: Events['error']) => any\n      if (this[ASYNC]) defer(() => h.call(this, this[EMITTED_ERROR]))\n      else h.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  /**\n   * Alias for {@link Minipass#off}\n   */\n  removeListener<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ) {\n    return this.off(ev, handler)\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.off`\n   *\n   * If a 'data' event handler is removed, and it was the last consumer\n   * (ie, there are no pipe destinations or other 'data' event listeners),\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  off<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ) {\n    const ret = super.off(\n      ev as string | symbol,\n      handler as (...a: any[]) => any\n    )\n    // if we previously had listeners, and now we don't, and we don't\n    // have any pipes, then stop the flow, unless it's been explicitly\n    // put in a discarded flowing state via stream.resume().\n    if (ev === 'data') {\n      this[DATALISTENERS] = this.listeners('data').length\n      if (\n        this[DATALISTENERS] === 0 &&\n        !this[DISCARDED] &&\n        !this[PIPES].length\n      ) {\n        this[FLOWING] = false\n      }\n    }\n    return ret\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.removeAllListeners`\n   *\n   * If all 'data' event handlers are removed, and they were the last consumer\n   * (ie, there are no pipe destinations), then the flow of data will stop\n   * until there is another consumer or {@link Minipass#resume} is explicitly\n   * called.\n   */\n  removeAllListeners<Event extends keyof Events>(ev?: Event) {\n    const ret = super.removeAllListeners(ev as string | symbol | undefined)\n    if (ev === 'data' || ev === undefined) {\n      this[DATALISTENERS] = 0\n      if (!this[DISCARDED] && !this[PIPES].length) {\n        this[FLOWING] = false\n      }\n    }\n    return ret\n  }\n\n  /**\n   * true if the 'end' event has been emitted\n   */\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.emit`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * If the stream has been destroyed, and the event is something other\n   * than 'close' or 'error', then `false` is returned and no handlers\n   * are called.\n   *\n   * If the event is 'end', and has already been emitted, then the event\n   * is ignored. If the stream is in a paused or non-flowing state, then\n   * the event will be deferred until data flow resumes. If the stream is\n   * async, then handlers will be called on the next tick rather than\n   * immediately.\n   *\n   * If the event is 'close', and 'end' has not yet been emitted, then\n   * the event will be deferred until after 'end' is emitted.\n   *\n   * If the event is 'error', and an AbortSignal was provided for the stream,\n   * and there are no listeners, then the event is ignored, matching the\n   * behavior of node core streams in the presense of an AbortSignal.\n   *\n   * If the event is 'finish' or 'prefinish', then all listeners will be\n   * removed after emitting the event, to prevent double-firing.\n   */\n  emit<Event extends keyof Events>(\n    ev: Event,\n    ...args: Events[Event]\n  ): boolean {\n    const data = args[0]\n    // error and close are only events allowed after calling destroy()\n    if (\n      ev !== 'error' &&\n      ev !== 'close' &&\n      ev !== DESTROYED &&\n      this[DESTROYED]\n    ) {\n      return false\n    } else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? (defer(() => this[EMITDATA](data as RType)), true)\n        : this[EMITDATA](data as RType)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return false\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret =\n        !this[SIGNAL] || this.listeners('error').length\n          ? super.emit('error', data)\n          : false\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev as string, ...args)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data: RType) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause()\n    }\n    const ret = this[DISCARDED] ? false : super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return false\n\n    this[EMITTED_END] = true\n    this.readable = false\n    return this[ASYNC]\n      ? (defer(() => this[EMITEND2]()), true)\n      : this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data as RType)\n        }\n        if (!this[DISCARDED]) super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  /**\n   * Return a Promise that resolves to an array of all emitted data once\n   * the stream ends.\n   */\n  async collect(): Promise<RType[] & { dataLength: number }> {\n    const buf: RType[] & { dataLength: number } = Object.assign([], {\n      dataLength: 0,\n    })\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += (c as Minipass.BufferOrString).length\n    })\n    await p\n    return buf\n  }\n\n  /**\n   * Return a Promise that resolves to the concatenation of all emitted data\n   * once the stream ends.\n   *\n   * Not allowed on objectMode streams.\n   */\n  async concat(): Promise<RType> {\n    if (this[OBJECTMODE]) {\n      throw new Error('cannot concat in objectMode')\n    }\n    const buf = await this.collect()\n    return (\n      this[ENCODING]\n        ? buf.join('')\n        : Buffer.concat(buf as Buffer[], buf.dataLength)\n    ) as RType\n  }\n\n  /**\n   * Return a void Promise that resolves once the stream ends.\n   */\n  async promise(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  /**\n   * Asynchronous `for await of` iteration.\n   *\n   * This will continue emitting all chunks until the stream terminates.\n   */\n  [Symbol.asyncIterator](): AsyncGenerator<RType, void, void> {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false\n    let stopped = false\n    const stop = async (): Promise<IteratorReturnResult<void>> => {\n      this.pause()\n      stopped = true\n      return { value: undefined, done: true }\n    }\n    const next = (): Promise<IteratorResult<RType, void>> => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve!: (res: IteratorResult<RType>) => void\n      let reject!: (er: unknown) => void\n      const onerr = (er: unknown) => {\n        this.off('data', ondata)\n        this.off('end', onend)\n        this.off(DESTROYED, ondestroy)\n        stop()\n        reject(er)\n      }\n      const ondata = (value: RType) => {\n        this.off('error', onerr)\n        this.off('end', onend)\n        this.off(DESTROYED, ondestroy)\n        this.pause()\n        resolve({ value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.off('error', onerr)\n        this.off('data', ondata)\n        this.off(DESTROYED, ondestroy)\n        stop()\n        resolve({ done: true, value: undefined })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise<IteratorResult<RType>>((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.asyncIterator]() {\n        return this\n      },\n    }\n  }\n\n  /**\n   * Synchronous `for of` iteration.\n   *\n   * The iteration will terminate when the internal buffer runs out, even\n   * if the stream has not yet terminated.\n   */\n  [Symbol.iterator](): Generator<RType, void, void> {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false\n    let stopped = false\n    const stop = (): IteratorReturnResult<void> => {\n      this.pause()\n      this.off(ERROR, stop)\n      this.off(DESTROYED, stop)\n      this.off('end', stop)\n      stopped = true\n      return { done: true, value: undefined }\n    }\n\n    const next = (): IteratorResult<RType, void> => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { done: false, value }\n    }\n\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(DESTROYED, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.iterator]() {\n        return this\n      },\n    }\n  }\n\n  /**\n   * Destroy a stream, preventing it from being used for any further purpose.\n   *\n   * If the stream has a `close()` method, then it will be called on\n   * destruction.\n   *\n   * After destruction, any attempt to write data, read data, or emit most\n   * events will be ignored.\n   *\n   * If an error argument is provided, then it will be emitted in an\n   * 'error' event.\n   */\n  destroy(er?: unknown) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n    this[DISCARDED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    const wc = this as Minipass<RType, WType, Events> & {\n      close?: () => void\n    }\n    if (typeof wc.close === 'function' && !this[CLOSED]) wc.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  /**\n   * Alias for {@link isStream}\n   *\n   * Former export location, maintained for backwards compatibility.\n   *\n   * @deprecated\n   */\n  static get isStream() {\n    return isStream\n  }\n}\n","import { Minimatch, MinimatchOptions } from 'minimatch'\nimport { Minipass } from 'minipass'\nimport {\n  FSOption,\n  Path,\n  PathScurry,\n  PathScurryDarwin,\n  PathScurryPosix,\n  PathScurryWin32,\n} from 'path-scurry'\nimport { fileURLToPath } from 'url'\nimport { IgnoreLike } from './ignore.js'\nimport { Pattern } from './pattern.js'\nimport { GlobStream, GlobWalker } from './walker.js'\n\nexport type MatchSet = Minimatch['set']\nexport type GlobParts = Exclude<Minimatch['globParts'], undefined>\n\n// if no process global, just call it linux.\n// so we default to case-sensitive, / separators\nconst defaultPlatform: NodeJS.Platform =\n  typeof process === 'object' &&\n  process &&\n  typeof process.platform === 'string'\n    ? process.platform\n    : 'linux'\n\n/**\n * A `GlobOptions` object may be provided to any of the exported methods, and\n * must be provided to the `Glob` constructor.\n *\n * All options are optional, boolean, and false by default, unless otherwise\n * noted.\n *\n * All resolved options are added to the Glob object as properties.\n *\n * If you are running many `glob` operations, you can pass a Glob object as the\n * `options` argument to a subsequent operation to share the previously loaded\n * cache.\n */\nexport interface GlobOptions {\n  /**\n   * Set to `true` to always receive absolute paths for\n   * matched files. Set to `false` to always return relative paths.\n   *\n   * When this option is not set, absolute paths are returned for patterns\n   * that are absolute, and otherwise paths are returned that are relative\n   * to the `cwd` setting.\n   *\n   * This does _not_ make an extra system call to get\n   * the realpath, it only does string path resolution.\n   *\n   * Conflicts with {@link withFileTypes}\n   */\n  absolute?: boolean\n\n  /**\n   * Set to false to enable {@link windowsPathsNoEscape}\n   *\n   * @deprecated\n   */\n  allowWindowsEscape?: boolean\n\n  /**\n   * The current working directory in which to search. Defaults to\n   * `process.cwd()`.\n   *\n   * May be eiher a string path or a `file://` URL object or string.\n   */\n  cwd?: string | URL\n\n  /**\n   * Include `.dot` files in normal matches and `globstar`\n   * matches. Note that an explicit dot in a portion of the pattern\n   * will always match dot files.\n   */\n  dot?: boolean\n\n  /**\n   * Prepend all relative path strings with `./` (or `.\\` on Windows).\n   *\n   * Without this option, returned relative paths are \"bare\", so instead of\n   * returning `'./foo/bar'`, they are returned as `'foo/bar'`.\n   *\n   * Relative patterns starting with `'../'` are not prepended with `./`, even\n   * if this option is set.\n   */\n  dotRelative?: boolean\n\n  /**\n   * Follow symlinked directories when expanding `**`\n   * patterns. This can result in a lot of duplicate references in\n   * the presence of cyclic links, and make performance quite bad.\n   *\n   * By default, a `**` in a pattern will follow 1 symbolic link if\n   * it is not the first item in the pattern, or none if it is the\n   * first item in the pattern, following the same behavior as Bash.\n   */\n  follow?: boolean\n\n  /**\n   * string or string[], or an object with `ignore` and `ignoreChildren`\n   * methods.\n   *\n   * If a string or string[] is provided, then this is treated as a glob\n   * pattern or array of glob patterns to exclude from matches. To ignore all\n   * children within a directory, as well as the entry itself, append `'/**'`\n   * to the ignore pattern.\n   *\n   * **Note** `ignore` patterns are _always_ in `dot:true` mode, regardless of\n   * any other settings.\n   *\n   * If an object is provided that has `ignored(path)` and/or\n   * `childrenIgnored(path)` methods, then these methods will be called to\n   * determine whether any Path is a match or if its children should be\n   * traversed, respectively.\n   */\n  ignore?: string | string[] | IgnoreLike\n\n  /**\n   * Treat brace expansion like `{a,b}` as a \"magic\" pattern. Has no\n   * effect if {@link nobrace} is set.\n   *\n   * Only has effect on the {@link hasMagic} function.\n   */\n  magicalBraces?: boolean\n\n  /**\n   * Add a `/` character to directory matches. Note that this requires\n   * additional stat calls in some cases.\n   */\n  mark?: boolean\n\n  /**\n   * Perform a basename-only match if the pattern does not contain any slash\n   * characters. That is, `*.js` would be treated as equivalent to\n   * `**\\/*.js`, matching all js files in all directories.\n   */\n  matchBase?: boolean\n\n  /**\n   * Limit the directory traversal to a given depth below the cwd.\n   * Note that this does NOT prevent traversal to sibling folders,\n   * root patterns, and so on. It only limits the maximum folder depth\n   * that the walk will descend, relative to the cwd.\n   */\n  maxDepth?: number\n\n  /**\n   * Do not expand `{a,b}` and `{1..3}` brace sets.\n   */\n  nobrace?: boolean\n\n  /**\n   * Perform a case-insensitive match. This defaults to `true` on macOS and\n   * Windows systems, and `false` on all others.\n   *\n   * **Note** `nocase` should only be explicitly set when it is\n   * known that the filesystem's case sensitivity differs from the\n   * platform default. If set `true` on case-sensitive file\n   * systems, or `false` on case-insensitive file systems, then the\n   * walk may return more or less results than expected.\n   */\n  nocase?: boolean\n\n  /**\n   * Do not match directories, only files. (Note: to match\n   * _only_ directories, put a `/` at the end of the pattern.)\n   */\n  nodir?: boolean\n\n  /**\n   * Do not match \"extglob\" patterns such as `+(a|b)`.\n   */\n  noext?: boolean\n\n  /**\n   * Do not match `**` against multiple filenames. (Ie, treat it as a normal\n   * `*` instead.)\n   *\n   * Conflicts with {@link matchBase}\n   */\n  noglobstar?: boolean\n\n  /**\n   * Defaults to value of `process.platform` if available, or `'linux'` if\n   * not. Setting `platform:'win32'` on non-Windows systems may cause strange\n   * behavior.\n   */\n  platform?: NodeJS.Platform\n\n  /**\n   * Set to true to call `fs.realpath` on all of the\n   * results. In the case of an entry that cannot be resolved, the\n   * entry is omitted. This incurs a slight performance penalty, of\n   * course, because of the added system calls.\n   */\n  realpath?: boolean\n\n  /**\n   *\n   * A string path resolved against the `cwd` option, which\n   * is used as the starting point for absolute patterns that start\n   * with `/`, (but not drive letters or UNC paths on Windows).\n   *\n   * Note that this _doesn't_ necessarily limit the walk to the\n   * `root` directory, and doesn't affect the cwd starting point for\n   * non-absolute patterns. A pattern containing `..` will still be\n   * able to traverse out of the root directory, if it is not an\n   * actual root directory on the filesystem, and any non-absolute\n   * patterns will be matched in the `cwd`. For example, the\n   * pattern `/../*` with `{root:'/some/path'}` will return all\n   * files in `/some`, not all files in `/some/path`. The pattern\n   * `*` with `{root:'/some/path'}` will return all the entries in\n   * the cwd, not the entries in `/some/path`.\n   *\n   * To start absolute and non-absolute patterns in the same\n   * path, you can use `{root:''}`. However, be aware that on\n   * Windows systems, a pattern like `x:/*` or `//host/share/*` will\n   * _always_ start in the `x:/` or `//host/share` directory,\n   * regardless of the `root` setting.\n   */\n  root?: string\n\n  /**\n   * A [PathScurry](http://npm.im/path-scurry) object used\n   * to traverse the file system. If the `nocase` option is set\n   * explicitly, then any provided `scurry` object must match this\n   * setting.\n   */\n  scurry?: PathScurry\n\n  /**\n   * Call `lstat()` on all entries, whether required or not to determine\n   * if it's a valid match. When used with {@link withFileTypes}, this means\n   * that matches will include data such as modified time, permissions, and\n   * so on.  Note that this will incur a performance cost due to the added\n   * system calls.\n   */\n  stat?: boolean\n\n  /**\n   * An AbortSignal which will cancel the Glob walk when\n   * triggered.\n   */\n  signal?: AbortSignal\n\n  /**\n   * Use `\\\\` as a path separator _only_, and\n   *  _never_ as an escape character. If set, all `\\\\` characters are\n   *  replaced with `/` in the pattern.\n   *\n   *  Note that this makes it **impossible** to match against paths\n   *  containing literal glob pattern characters, but allows matching\n   *  with patterns constructed using `path.join()` and\n   *  `path.resolve()` on Windows platforms, mimicking the (buggy!)\n   *  behavior of Glob v7 and before on Windows. Please use with\n   *  caution, and be mindful of [the caveat below about Windows\n   *  paths](#windows). (For legacy reasons, this is also set if\n   *  `allowWindowsEscape` is set to the exact value `false`.)\n   */\n  windowsPathsNoEscape?: boolean\n\n  /**\n   * Return [PathScurry](http://npm.im/path-scurry)\n   * `Path` objects instead of strings. These are similar to a\n   * NodeJS `Dirent` object, but with additional methods and\n   * properties.\n   *\n   * Conflicts with {@link absolute}\n   */\n  withFileTypes?: boolean\n\n  /**\n   * An fs implementation to override some or all of the defaults.  See\n   * http://npm.im/path-scurry for details about what can be overridden.\n   */\n  fs?: FSOption\n\n  /**\n   * Just passed along to Minimatch.  Note that this makes all pattern\n   * matching operations slower and *extremely* noisy.\n   */\n  debug?: boolean\n\n  /**\n   * Return `/` delimited paths, even on Windows.\n   *\n   * On posix systems, this has no effect.  But, on Windows, it means that\n   * paths will be `/` delimited, and absolute paths will be their full\n   * resolved UNC forms, eg instead of `'C:\\\\foo\\\\bar'`, it would return\n   * `'//?/C:/foo/bar'`\n   */\n  posix?: boolean\n}\n\nexport type GlobOptionsWithFileTypesTrue = GlobOptions & {\n  withFileTypes: true\n  // string options not relevant if returning Path objects.\n  absolute?: undefined\n  mark?: undefined\n  posix?: undefined\n}\n\nexport type GlobOptionsWithFileTypesFalse = GlobOptions & {\n  withFileTypes?: false\n}\n\nexport type GlobOptionsWithFileTypesUnset = GlobOptions & {\n  withFileTypes?: undefined\n}\n\nexport type Result<Opts> = Opts extends GlobOptionsWithFileTypesTrue\n  ? Path\n  : Opts extends GlobOptionsWithFileTypesFalse\n  ? string\n  : Opts extends GlobOptionsWithFileTypesUnset\n  ? string\n  : string | Path\nexport type Results<Opts> = Result<Opts>[]\n\nexport type FileTypes<Opts> = Opts extends GlobOptionsWithFileTypesTrue\n  ? true\n  : Opts extends GlobOptionsWithFileTypesFalse\n  ? false\n  : Opts extends GlobOptionsWithFileTypesUnset\n  ? false\n  : boolean\n\n/**\n * An object that can perform glob pattern traversals.\n */\nexport class Glob<Opts extends GlobOptions> implements GlobOptions {\n  absolute?: boolean\n  cwd: string\n  root?: string\n  dot: boolean\n  dotRelative: boolean\n  follow: boolean\n  ignore?: string | string[] | IgnoreLike\n  magicalBraces: boolean\n  mark?: boolean\n  matchBase: boolean\n  maxDepth: number\n  nobrace: boolean\n  nocase: boolean\n  nodir: boolean\n  noext: boolean\n  noglobstar: boolean\n  pattern: string[]\n  platform: NodeJS.Platform\n  realpath: boolean\n  scurry: PathScurry\n  stat: boolean\n  signal?: AbortSignal\n  windowsPathsNoEscape: boolean\n  withFileTypes: FileTypes<Opts>\n\n  /**\n   * The options provided to the constructor.\n   */\n  opts: Opts\n\n  /**\n   * An array of parsed immutable {@link Pattern} objects.\n   */\n  patterns: Pattern[]\n\n  /**\n   * All options are stored as properties on the `Glob` object.\n   *\n   * See {@link GlobOptions} for full options descriptions.\n   *\n   * Note that a previous `Glob` object can be passed as the\n   * `GlobOptions` to another `Glob` instantiation to re-use settings\n   * and caches with a new pattern.\n   *\n   * Traversal functions can be called multiple times to run the walk\n   * again.\n   */\n  constructor(pattern: string | string[], opts: Opts) {\n    /* c8 ignore start */\n    if (!opts) throw new TypeError('glob options required')\n    /* c8 ignore stop */\n    this.withFileTypes = !!opts.withFileTypes as FileTypes<Opts>\n    this.signal = opts.signal\n    this.follow = !!opts.follow\n    this.dot = !!opts.dot\n    this.dotRelative = !!opts.dotRelative\n    this.nodir = !!opts.nodir\n    this.mark = !!opts.mark\n    if (!opts.cwd) {\n      this.cwd = ''\n    } else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {\n      opts.cwd = fileURLToPath(opts.cwd)\n    }\n    this.cwd = opts.cwd || ''\n    this.root = opts.root\n    this.magicalBraces = !!opts.magicalBraces\n    this.nobrace = !!opts.nobrace\n    this.noext = !!opts.noext\n    this.realpath = !!opts.realpath\n    this.absolute = opts.absolute\n\n    this.noglobstar = !!opts.noglobstar\n    this.matchBase = !!opts.matchBase\n    this.maxDepth =\n      typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity\n    this.stat = !!opts.stat\n    this.ignore = opts.ignore\n\n    if (this.withFileTypes && this.absolute !== undefined) {\n      throw new Error('cannot set absolute and withFileTypes:true')\n    }\n\n    if (typeof pattern === 'string') {\n      pattern = [pattern]\n    }\n\n    this.windowsPathsNoEscape =\n      !!opts.windowsPathsNoEscape ||\n      (opts as GlobOptions).allowWindowsEscape === false\n\n    if (this.windowsPathsNoEscape) {\n      pattern = pattern.map(p => p.replace(/\\\\/g, '/'))\n    }\n\n    if (this.matchBase) {\n      if (opts.noglobstar) {\n        throw new TypeError('base matching requires globstar')\n      }\n      pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`))\n    }\n\n    this.pattern = pattern\n\n    this.platform = opts.platform || defaultPlatform\n    this.opts = { ...opts, platform: this.platform }\n    if (opts.scurry) {\n      this.scurry = opts.scurry\n      if (\n        opts.nocase !== undefined &&\n        opts.nocase !== opts.scurry.nocase\n      ) {\n        throw new Error('nocase option contradicts provided scurry option')\n      }\n    } else {\n      const Scurry =\n        opts.platform === 'win32'\n          ? PathScurryWin32\n          : opts.platform === 'darwin'\n          ? PathScurryDarwin\n          : opts.platform\n          ? PathScurryPosix\n          : PathScurry\n      this.scurry = new Scurry(this.cwd, {\n        nocase: opts.nocase,\n        fs: opts.fs,\n      })\n    }\n    this.nocase = this.scurry.nocase\n\n    // If you do nocase:true on a case-sensitive file system, then\n    // we need to use regexps instead of strings for non-magic\n    // path portions, because statting `aBc` won't return results\n    // for the file `AbC` for example.\n    const nocaseMagicOnly =\n      this.platform === 'darwin' || this.platform === 'win32'\n\n    const mmo: MinimatchOptions = {\n      // default nocase based on platform\n      ...opts,\n      dot: this.dot,\n      matchBase: this.matchBase,\n      nobrace: this.nobrace,\n      nocase: this.nocase,\n      nocaseMagicOnly,\n      nocomment: true,\n      noext: this.noext,\n      nonegate: true,\n      optimizationLevel: 2,\n      platform: this.platform,\n      windowsPathsNoEscape: this.windowsPathsNoEscape,\n      debug: !!this.opts.debug,\n    }\n\n    const mms = this.pattern.map(p => new Minimatch(p, mmo))\n    const [matchSet, globParts] = mms.reduce(\n      (set: [MatchSet, GlobParts], m) => {\n        set[0].push(...m.set)\n        set[1].push(...m.globParts)\n        return set\n      },\n      [[], []]\n    )\n    this.patterns = matchSet.map((set, i) => {\n      const g = globParts[i]\n      /* c8 ignore start */\n      if (!g) throw new Error('invalid pattern object')\n      /* c8 ignore stop */\n      return new Pattern(set, g, 0, this.platform)\n    })\n  }\n\n  /**\n   * Returns a Promise that resolves to the results array.\n   */\n  async walk(): Promise<Results<Opts>>\n  async walk(): Promise<(string | Path)[]> {\n    // Walkers always return array of Path objects, so we just have to\n    // coerce them into the right shape.  It will have already called\n    // realpath() if the option was set to do so, so we know that's cached.\n    // start out knowing the cwd, at least\n    return [\n      ...(await new GlobWalker(this.patterns, this.scurry.cwd, {\n        ...this.opts,\n        maxDepth:\n          this.maxDepth !== Infinity\n            ? this.maxDepth + this.scurry.cwd.depth()\n            : Infinity,\n        platform: this.platform,\n        nocase: this.nocase,\n      }).walk()),\n    ]\n  }\n\n  /**\n   * synchronous {@link Glob.walk}\n   */\n  walkSync(): Results<Opts>\n  walkSync(): (string | Path)[] {\n    return [\n      ...new GlobWalker(this.patterns, this.scurry.cwd, {\n        ...this.opts,\n        maxDepth:\n          this.maxDepth !== Infinity\n            ? this.maxDepth + this.scurry.cwd.depth()\n            : Infinity,\n        platform: this.platform,\n        nocase: this.nocase,\n      }).walkSync(),\n    ]\n  }\n\n  /**\n   * Stream results asynchronously.\n   */\n  stream(): Minipass<Result<Opts>, Result<Opts>>\n  stream(): Minipass<string | Path, string | Path> {\n    return new GlobStream(this.patterns, this.scurry.cwd, {\n      ...this.opts,\n      maxDepth:\n        this.maxDepth !== Infinity\n          ? this.maxDepth + this.scurry.cwd.depth()\n          : Infinity,\n      platform: this.platform,\n      nocase: this.nocase,\n    }).stream()\n  }\n\n  /**\n   * Stream results synchronously.\n   */\n  streamSync(): Minipass<Result<Opts>, Result<Opts>>\n  streamSync(): Minipass<string | Path, string | Path> {\n    return new GlobStream(this.patterns, this.scurry.cwd, {\n      ...this.opts,\n      maxDepth:\n        this.maxDepth !== Infinity\n          ? this.maxDepth + this.scurry.cwd.depth()\n          : Infinity,\n      platform: this.platform,\n      nocase: this.nocase,\n    }).streamSync()\n  }\n\n  /**\n   * Default sync iteration function. Returns a Generator that\n   * iterates over the results.\n   */\n  iterateSync(): Generator<Result<Opts>, void, void> {\n    return this.streamSync()[Symbol.iterator]()\n  }\n  [Symbol.iterator]() {\n    return this.iterateSync()\n  }\n\n  /**\n   * Default async iteration function. Returns an AsyncGenerator that\n   * iterates over the results.\n   */\n  iterate(): AsyncGenerator<Result<Opts>, void, void> {\n    return this.stream()[Symbol.asyncIterator]()\n  }\n  [Symbol.asyncIterator]() {\n    return this.iterate()\n  }\n}\n","// this is just a very light wrapper around 2 arrays with an offset index\n\nimport { GLOBSTAR } from 'minimatch'\nexport type MMPattern = string | RegExp | typeof GLOBSTAR\n\n// an array of length >= 1\nexport type PatternList = [p: MMPattern, ...rest: MMPattern[]]\nexport type UNCPatternList = [\n  p0: '',\n  p1: '',\n  p2: string,\n  p3: string,\n  ...rest: MMPattern[]\n]\nexport type DrivePatternList = [p0: string, ...rest: MMPattern[]]\nexport type AbsolutePatternList = [p0: '', ...rest: MMPattern[]]\nexport type GlobList = [p: string, ...rest: string[]]\n\nconst isPatternList = (pl: MMPattern[]): pl is PatternList =>\n  pl.length >= 1\nconst isGlobList = (gl: string[]): gl is GlobList => gl.length >= 1\n\n/**\n * An immutable-ish view on an array of glob parts and their parsed\n * results\n */\nexport class Pattern {\n  readonly #patternList: PatternList\n  readonly #globList: GlobList\n  readonly #index: number\n  readonly length: number\n  readonly #platform: NodeJS.Platform\n  #rest?: Pattern | null\n  #globString?: string\n  #isDrive?: boolean\n  #isUNC?: boolean\n  #isAbsolute?: boolean\n  #followGlobstar: boolean = true\n\n  constructor(\n    patternList: MMPattern[],\n    globList: string[],\n    index: number,\n    platform: NodeJS.Platform\n  ) {\n    if (!isPatternList(patternList)) {\n      throw new TypeError('empty pattern list')\n    }\n    if (!isGlobList(globList)) {\n      throw new TypeError('empty glob list')\n    }\n    if (globList.length !== patternList.length) {\n      throw new TypeError('mismatched pattern list and glob list lengths')\n    }\n    this.length = patternList.length\n    if (index < 0 || index >= this.length) {\n      throw new TypeError('index out of range')\n    }\n    this.#patternList = patternList\n    this.#globList = globList\n    this.#index = index\n    this.#platform = platform\n\n    // normalize root entries of absolute patterns on initial creation.\n    if (this.#index === 0) {\n      // c: => ['c:/']\n      // C:/ => ['C:/']\n      // C:/x => ['C:/', 'x']\n      // //host/share => ['//host/share/']\n      // //host/share/ => ['//host/share/']\n      // //host/share/x => ['//host/share/', 'x']\n      // /etc => ['/', 'etc']\n      // / => ['/']\n      if (this.isUNC()) {\n        // '' / '' / 'host' / 'share'\n        const [p0, p1, p2, p3, ...prest] = this.#patternList\n        const [g0, g1, g2, g3, ...grest] = this.#globList\n        if (prest[0] === '') {\n          // ends in /\n          prest.shift()\n          grest.shift()\n        }\n        const p = [p0, p1, p2, p3, ''].join('/')\n        const g = [g0, g1, g2, g3, ''].join('/')\n        this.#patternList = [p, ...prest]\n        this.#globList = [g, ...grest]\n        this.length = this.#patternList.length\n      } else if (this.isDrive() || this.isAbsolute()) {\n        const [p1, ...prest] = this.#patternList\n        const [g1, ...grest] = this.#globList\n        if (prest[0] === '') {\n          // ends in /\n          prest.shift()\n          grest.shift()\n        }\n        const p = (p1 as string) + '/'\n        const g = g1 + '/'\n        this.#patternList = [p, ...prest]\n        this.#globList = [g, ...grest]\n        this.length = this.#patternList.length\n      }\n    }\n  }\n\n  /**\n   * The first entry in the parsed list of patterns\n   */\n  pattern(): MMPattern {\n    return this.#patternList[this.#index] as MMPattern\n  }\n\n  /**\n   * true of if pattern() returns a string\n   */\n  isString(): boolean {\n    return typeof this.#patternList[this.#index] === 'string'\n  }\n  /**\n   * true of if pattern() returns GLOBSTAR\n   */\n  isGlobstar(): boolean {\n    return this.#patternList[this.#index] === GLOBSTAR\n  }\n  /**\n   * true if pattern() returns a regexp\n   */\n  isRegExp(): boolean {\n    return this.#patternList[this.#index] instanceof RegExp\n  }\n\n  /**\n   * The /-joined set of glob parts that make up this pattern\n   */\n  globString(): string {\n    return (this.#globString =\n      this.#globString ||\n      (this.#index === 0\n        ? this.isAbsolute()\n          ? this.#globList[0] + this.#globList.slice(1).join('/')\n          : this.#globList.join('/')\n        : this.#globList.slice(this.#index).join('/')))\n  }\n\n  /**\n   * true if there are more pattern parts after this one\n   */\n  hasMore(): boolean {\n    return this.length > this.#index + 1\n  }\n\n  /**\n   * The rest of the pattern after this part, or null if this is the end\n   */\n  rest(): Pattern | null {\n    if (this.#rest !== undefined) return this.#rest\n    if (!this.hasMore()) return (this.#rest = null)\n    this.#rest = new Pattern(\n      this.#patternList,\n      this.#globList,\n      this.#index + 1,\n      this.#platform\n    )\n    this.#rest.#isAbsolute = this.#isAbsolute\n    this.#rest.#isUNC = this.#isUNC\n    this.#rest.#isDrive = this.#isDrive\n    return this.#rest\n  }\n\n  /**\n   * true if the pattern represents a //unc/path/ on windows\n   */\n  isUNC(): boolean {\n    const pl = this.#patternList\n    return this.#isUNC !== undefined\n      ? this.#isUNC\n      : (this.#isUNC =\n          this.#platform === 'win32' &&\n          this.#index === 0 &&\n          pl[0] === '' &&\n          pl[1] === '' &&\n          typeof pl[2] === 'string' &&\n          !!pl[2] &&\n          typeof pl[3] === 'string' &&\n          !!pl[3])\n  }\n\n  // pattern like C:/...\n  // split = ['C:', ...]\n  // XXX: would be nice to handle patterns like `c:*` to test the cwd\n  // in c: for *, but I don't know of a way to even figure out what that\n  // cwd is without actually chdir'ing into it?\n  /**\n   * True if the pattern starts with a drive letter on Windows\n   */\n  isDrive(): boolean {\n    const pl = this.#patternList\n    return this.#isDrive !== undefined\n      ? this.#isDrive\n      : (this.#isDrive =\n          this.#platform === 'win32' &&\n          this.#index === 0 &&\n          this.length > 1 &&\n          typeof pl[0] === 'string' &&\n          /^[a-z]:$/i.test(pl[0]))\n  }\n\n  // pattern = '/' or '/...' or '/x/...'\n  // split = ['', ''] or ['', ...] or ['', 'x', ...]\n  // Drive and UNC both considered absolute on windows\n  /**\n   * True if the pattern is rooted on an absolute path\n   */\n  isAbsolute(): boolean {\n    const pl = this.#patternList\n    return this.#isAbsolute !== undefined\n      ? this.#isAbsolute\n      : (this.#isAbsolute =\n          (pl[0] === '' && pl.length > 1) ||\n          this.isDrive() ||\n          this.isUNC())\n  }\n\n  /**\n   * consume the root of the pattern, and return it\n   */\n  root(): string {\n    const p = this.#patternList[0]\n    return typeof p === 'string' && this.isAbsolute() && this.#index === 0\n      ? p\n      : ''\n  }\n\n  /**\n   * Check to see if the current globstar pattern is allowed to follow\n   * a symbolic link.\n   */\n  checkFollowGlobstar(): boolean {\n    return !(\n      this.#index === 0 ||\n      !this.isGlobstar() ||\n      !this.#followGlobstar\n    )\n  }\n\n  /**\n   * Mark that the current globstar pattern is following a symbolic link\n   */\n  markFollowGlobstar(): boolean {\n    if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)\n      return false\n    this.#followGlobstar = false\n    return true\n  }\n}\n","// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\n\nimport { Minimatch } from 'minimatch'\nimport { Path } from 'path-scurry'\nimport { Pattern } from './pattern.js'\nimport { GlobWalkerOpts } from './walker.js'\n\nexport interface IgnoreLike {\n  ignored?: (p: Path) => boolean\n  childrenIgnored?: (p: Path) => boolean\n}\n\nconst defaultPlatform: NodeJS.Platform =\n  typeof process === 'object' &&\n  process &&\n  typeof process.platform === 'string'\n    ? process.platform\n    : 'linux'\n\n/**\n * Class used to process ignored patterns\n */\nexport class Ignore implements IgnoreLike {\n  relative: Minimatch[]\n  relativeChildren: Minimatch[]\n  absolute: Minimatch[]\n  absoluteChildren: Minimatch[]\n\n  constructor(\n    ignored: string[],\n    {\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      platform = defaultPlatform,\n    }: GlobWalkerOpts\n  ) {\n    this.relative = []\n    this.absolute = []\n    this.relativeChildren = []\n    this.absoluteChildren = []\n    const mmopts = {\n      dot: true,\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      optimizationLevel: 2,\n      platform,\n      nocomment: true,\n      nonegate: true,\n    }\n\n    // this is a little weird, but it gives us a clean set of optimized\n    // minimatch matchers, without getting tripped up if one of them\n    // ends in /** inside a brace section, and it's only inefficient at\n    // the start of the walk, not along it.\n    // It'd be nice if the Pattern class just had a .test() method, but\n    // handling globstars is a bit of a pita, and that code already lives\n    // in minimatch anyway.\n    // Another way would be if maybe Minimatch could take its set/globParts\n    // as an option, and then we could at least just use Pattern to test\n    // for absolute-ness.\n    // Yet another way, Minimatch could take an array of glob strings, and\n    // a cwd option, and do the right thing.\n    for (const ign of ignored) {\n      const mm = new Minimatch(ign, mmopts)\n      for (let i = 0; i < mm.set.length; i++) {\n        const parsed = mm.set[i]\n        const globParts = mm.globParts[i]\n        /* c8 ignore start */\n        if (!parsed || !globParts) {\n          throw new Error('invalid pattern object')\n        }\n        /* c8 ignore stop */\n        const p = new Pattern(parsed, globParts, 0, platform)\n        const m = new Minimatch(p.globString(), mmopts)\n        const children = globParts[globParts.length - 1] === '**'\n        const absolute = p.isAbsolute()\n        if (absolute) this.absolute.push(m)\n        else this.relative.push(m)\n        if (children) {\n          if (absolute) this.absoluteChildren.push(m)\n          else this.relativeChildren.push(m)\n        }\n      }\n    }\n  }\n\n  ignored(p: Path): boolean {\n    const fullpath = p.fullpath()\n    const fullpaths = `${fullpath}/`\n    const relative = p.relative() || '.'\n    const relatives = `${relative}/`\n    for (const m of this.relative) {\n      if (m.match(relative) || m.match(relatives)) return true\n    }\n    for (const m of this.absolute) {\n      if (m.match(fullpath) || m.match(fullpaths)) return true\n    }\n    return false\n  }\n\n  childrenIgnored(p: Path): boolean {\n    const fullpath = p.fullpath() + '/'\n    const relative = (p.relative() || '.') + '/'\n    for (const m of this.relativeChildren) {\n      if (m.match(relative)) return true\n    }\n    for (const m of this.absoluteChildren) {\n      if (m.match(fullpath)) return true\n    }\n    return false\n  }\n}\n","// synchronous utility for filtering entries and calculating subwalks\n\nimport { GLOBSTAR, MMRegExp } from 'minimatch'\nimport { Path } from 'path-scurry'\nimport { MMPattern, Pattern } from './pattern.js'\nimport { GlobWalkerOpts } from './walker.js'\n\n/**\n * A cache of which patterns have been processed for a given Path\n */\nexport class HasWalkedCache {\n  store: Map<string, Set<string>>\n  constructor(store: Map<string, Set<string>> = new Map()) {\n    this.store = store\n  }\n  copy() {\n    return new HasWalkedCache(new Map(this.store))\n  }\n  hasWalked(target: Path, pattern: Pattern) {\n    return this.store.get(target.fullpath())?.has(pattern.globString())\n  }\n  storeWalked(target: Path, pattern: Pattern) {\n    const fullpath = target.fullpath()\n    const cached = this.store.get(fullpath)\n    if (cached) cached.add(pattern.globString())\n    else this.store.set(fullpath, new Set([pattern.globString()]))\n  }\n}\n\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nexport class MatchRecord {\n  store: Map<Path, number> = new Map()\n  add(target: Path, absolute: boolean, ifDir: boolean) {\n    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0)\n    const current = this.store.get(target)\n    this.store.set(target, current === undefined ? n : n & current)\n  }\n  // match, absolute, ifdir\n  entries(): [Path, boolean, boolean][] {\n    return [...this.store.entries()].map(([path, n]) => [\n      path,\n      !!(n & 2),\n      !!(n & 1),\n    ])\n  }\n}\n\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nexport class SubWalks {\n  store: Map<Path, Pattern[]> = new Map()\n  add(target: Path, pattern: Pattern) {\n    if (!target.canReaddir()) {\n      return\n    }\n    const subs = this.store.get(target)\n    if (subs) {\n      if (!subs.find(p => p.globString() === pattern.globString())) {\n        subs.push(pattern)\n      }\n    } else this.store.set(target, [pattern])\n  }\n  get(target: Path): Pattern[] {\n    const subs = this.store.get(target)\n    /* c8 ignore start */\n    if (!subs) {\n      throw new Error('attempting to walk unknown path')\n    }\n    /* c8 ignore stop */\n    return subs\n  }\n  entries(): [Path, Pattern[]][] {\n    return this.keys().map(k => [k, this.store.get(k) as Pattern[]])\n  }\n  keys(): Path[] {\n    return [...this.store.keys()].filter(t => t.canReaddir())\n  }\n}\n\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nexport class Processor {\n  hasWalkedCache: HasWalkedCache\n  matches = new MatchRecord()\n  subwalks = new SubWalks()\n  patterns?: Pattern[]\n  follow: boolean\n  dot: boolean\n  opts: GlobWalkerOpts\n\n  constructor(opts: GlobWalkerOpts, hasWalkedCache?: HasWalkedCache) {\n    this.opts = opts\n    this.follow = !!opts.follow\n    this.dot = !!opts.dot\n    this.hasWalkedCache = hasWalkedCache\n      ? hasWalkedCache.copy()\n      : new HasWalkedCache()\n  }\n\n  processPatterns(target: Path, patterns: Pattern[]) {\n    this.patterns = patterns\n    const processingSet: [Path, Pattern][] = patterns.map(p => [target, p])\n\n    // map of paths to the magic-starting subwalks they need to walk\n    // first item in patterns is the filter\n\n    for (let [t, pattern] of processingSet) {\n      this.hasWalkedCache.storeWalked(t, pattern)\n\n      const root = pattern.root()\n      const absolute = pattern.isAbsolute() && this.opts.absolute !== false\n\n      // start absolute patterns at root\n      if (root) {\n        t = t.resolve(\n          root === '/' && this.opts.root !== undefined\n            ? this.opts.root\n            : root\n        )\n        const rest = pattern.rest()\n        if (!rest) {\n          this.matches.add(t, true, false)\n          continue\n        } else {\n          pattern = rest\n        }\n      }\n\n      if (t.isENOENT()) continue\n\n      let p: MMPattern\n      let rest: Pattern | null\n      let changed = false\n      while (\n        typeof (p = pattern.pattern()) === 'string' &&\n        (rest = pattern.rest())\n      ) {\n        const c = t.resolve(p)\n        t = c\n        pattern = rest\n        changed = true\n      }\n      p = pattern.pattern()\n      rest = pattern.rest()\n      if (changed) {\n        if (this.hasWalkedCache.hasWalked(t, pattern)) continue\n        this.hasWalkedCache.storeWalked(t, pattern)\n      }\n\n      // now we have either a final string for a known entry,\n      // more strings for an unknown entry,\n      // or a pattern starting with magic, mounted on t.\n      if (typeof p === 'string') {\n        // must not be final entry, otherwise we would have\n        // concatenated it earlier.\n        const ifDir = p === '..' || p === '' || p === '.'\n        this.matches.add(t.resolve(p), absolute, ifDir)\n        continue\n      } else if (p === GLOBSTAR) {\n        // if no rest, match and subwalk pattern\n        // if rest, process rest and subwalk pattern\n        // if it's a symlink, but we didn't get here by way of a\n        // globstar match (meaning it's the first time THIS globstar\n        // has traversed a symlink), then we follow it. Otherwise, stop.\n        if (\n          !t.isSymbolicLink() ||\n          this.follow ||\n          pattern.checkFollowGlobstar()\n        ) {\n          this.subwalks.add(t, pattern)\n        }\n        const rp = rest?.pattern()\n        const rrest = rest?.rest()\n        if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n          // only HAS to be a dir if it ends in **/ or **/.\n          // but ending in ** will match files as well.\n          this.matches.add(t, absolute, rp === '' || rp === '.')\n        } else {\n          if (rp === '..') {\n            // this would mean you're matching **/.. at the fs root,\n            // and no thanks, I'm not gonna test that specific case.\n            /* c8 ignore start */\n            const tp = t.parent || t\n            /* c8 ignore stop */\n            if (!rrest) this.matches.add(tp, absolute, true)\n            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n              this.subwalks.add(tp, rrest)\n            }\n          }\n        }\n      } else if (p instanceof RegExp) {\n        this.subwalks.add(t, pattern)\n      }\n    }\n\n    return this\n  }\n\n  subwalkTargets(): Path[] {\n    return this.subwalks.keys()\n  }\n\n  child() {\n    return new Processor(this.opts, this.hasWalkedCache)\n  }\n\n  // return a new Processor containing the subwalks for each\n  // child entry, and a set of matches, and\n  // a hasWalkedCache that's a copy of this one\n  // then we're going to call\n  filterEntries(parent: Path, entries: Path[]): Processor {\n    const patterns = this.subwalks.get(parent)\n    // put matches and entry walks into the results processor\n    const results = this.child()\n    for (const e of entries) {\n      for (const pattern of patterns) {\n        const absolute = pattern.isAbsolute()\n        const p = pattern.pattern()\n        const rest = pattern.rest()\n        if (p === GLOBSTAR) {\n          results.testGlobstar(e, pattern, rest, absolute)\n        } else if (p instanceof RegExp) {\n          results.testRegExp(e, p, rest, absolute)\n        } else {\n          results.testString(e, p, rest, absolute)\n        }\n      }\n    }\n    return results\n  }\n\n  testGlobstar(\n    e: Path,\n    pattern: Pattern,\n    rest: Pattern | null,\n    absolute: boolean\n  ) {\n    if (this.dot || !e.name.startsWith('.')) {\n      if (!pattern.hasMore()) {\n        this.matches.add(e, absolute, false)\n      }\n      if (e.canReaddir()) {\n        // if we're in follow mode or it's not a symlink, just keep\n        // testing the same pattern. If there's more after the globstar,\n        // then this symlink consumes the globstar. If not, then we can\n        // follow at most ONE symlink along the way, so we mark it, which\n        // also checks to ensure that it wasn't already marked.\n        if (this.follow || !e.isSymbolicLink()) {\n          this.subwalks.add(e, pattern)\n        } else if (e.isSymbolicLink()) {\n          if (rest && pattern.checkFollowGlobstar()) {\n            this.subwalks.add(e, rest)\n          } else if (pattern.markFollowGlobstar()) {\n            this.subwalks.add(e, pattern)\n          }\n        }\n      }\n    }\n    // if the NEXT thing matches this entry, then also add\n    // the rest.\n    if (rest) {\n      const rp = rest.pattern()\n      if (\n        typeof rp === 'string' &&\n        // dots and empty were handled already\n        rp !== '..' &&\n        rp !== '' &&\n        rp !== '.'\n      ) {\n        this.testString(e, rp, rest.rest(), absolute)\n      } else if (rp === '..') {\n        /* c8 ignore start */\n        const ep = e.parent || e\n        /* c8 ignore stop */\n        this.subwalks.add(ep, rest)\n      } else if (rp instanceof RegExp) {\n        this.testRegExp(e, rp, rest.rest(), absolute)\n      }\n    }\n  }\n\n  testRegExp(\n    e: Path,\n    p: MMRegExp,\n    rest: Pattern | null,\n    absolute: boolean\n  ) {\n    if (!p.test(e.name)) return\n    if (!rest) {\n      this.matches.add(e, absolute, false)\n    } else {\n      this.subwalks.add(e, rest)\n    }\n  }\n\n  testString(e: Path, p: string, rest: Pattern | null, absolute: boolean) {\n    // should never happen?\n    if (!e.isNamed(p)) return\n    if (!rest) {\n      this.matches.add(e, absolute, false)\n    } else {\n      this.subwalks.add(e, rest)\n    }\n  }\n}\n","/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nimport { Minipass } from 'minipass'\nimport { Path } from 'path-scurry'\nimport { Ignore, IgnoreLike } from './ignore.js'\n\n// XXX can we somehow make it so that it NEVER processes a given path more than\n// once, enough that the match set tracking is no longer needed?  that'd speed\n// things up a lot.  Or maybe bring back nounique, and skip it in that case?\n\n// a single minimatch set entry with 1 or more parts\nimport { Pattern } from './pattern.js'\nimport { Processor } from './processor.js'\n\nexport interface GlobWalkerOpts {\n  absolute?: boolean\n  allowWindowsEscape?: boolean\n  cwd?: string | URL\n  dot?: boolean\n  dotRelative?: boolean\n  follow?: boolean\n  ignore?: string | string[] | IgnoreLike\n  mark?: boolean\n  matchBase?: boolean\n  // Note: maxDepth here means \"maximum actual Path.depth()\",\n  // not \"maximum depth beyond cwd\"\n  maxDepth?: number\n  nobrace?: boolean\n  nocase?: boolean\n  nodir?: boolean\n  noext?: boolean\n  noglobstar?: boolean\n  platform?: NodeJS.Platform\n  posix?: boolean\n  realpath?: boolean\n  root?: string\n  stat?: boolean\n  signal?: AbortSignal\n  windowsPathsNoEscape?: boolean\n  withFileTypes?: boolean\n}\n\nexport type GWOFileTypesTrue = GlobWalkerOpts & {\n  withFileTypes: true\n}\nexport type GWOFileTypesFalse = GlobWalkerOpts & {\n  withFileTypes: false\n}\nexport type GWOFileTypesUnset = GlobWalkerOpts & {\n  withFileTypes?: undefined\n}\n\nexport type Result<O extends GlobWalkerOpts> = O extends GWOFileTypesTrue\n  ? Path\n  : O extends GWOFileTypesFalse\n  ? string\n  : O extends GWOFileTypesUnset\n  ? string\n  : Path | string\n\nexport type Matches<O extends GlobWalkerOpts> = O extends GWOFileTypesTrue\n  ? Set<Path>\n  : O extends GWOFileTypesFalse\n  ? Set<string>\n  : O extends GWOFileTypesUnset\n  ? Set<string>\n  : Set<Path | string>\n\nexport type MatchStream<O extends GlobWalkerOpts> =\n  O extends GWOFileTypesTrue\n    ? Minipass<Path, Path>\n    : O extends GWOFileTypesFalse\n    ? Minipass<string, string>\n    : O extends GWOFileTypesUnset\n    ? Minipass<string, string>\n    : Minipass<Path | string, Path | string>\n\nconst makeIgnore = (\n  ignore: string | string[] | IgnoreLike,\n  opts: GlobWalkerOpts\n): IgnoreLike =>\n  typeof ignore === 'string'\n    ? new Ignore([ignore], opts)\n    : Array.isArray(ignore)\n    ? new Ignore(ignore, opts)\n    : ignore\n\n/**\n * basic walking utilities that all the glob walker types use\n */\nexport abstract class GlobUtil<O extends GlobWalkerOpts = GlobWalkerOpts> {\n  path: Path\n  patterns: Pattern[]\n  opts: O\n  seen: Set<Path> = new Set<Path>()\n  paused: boolean = false\n  aborted: boolean = false\n  #onResume: (() => any)[] = []\n  #ignore?: IgnoreLike\n  #sep: '\\\\' | '/'\n  signal?: AbortSignal\n  maxDepth: number\n\n  constructor(patterns: Pattern[], path: Path, opts: O)\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    this.patterns = patterns\n    this.path = path\n    this.opts = opts\n    this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/'\n    if (opts.ignore) {\n      this.#ignore = makeIgnore(opts.ignore, opts)\n    }\n    // ignore, always set with maxDepth, but it's optional on the\n    // GlobOptions type\n    /* c8 ignore start */\n    this.maxDepth = opts.maxDepth || Infinity\n    /* c8 ignore stop */\n    if (opts.signal) {\n      this.signal = opts.signal\n      this.signal.addEventListener('abort', () => {\n        this.#onResume.length = 0\n      })\n    }\n  }\n\n  #ignored(path: Path): boolean {\n    return this.seen.has(path) || !!this.#ignore?.ignored?.(path)\n  }\n  #childrenIgnored(path: Path): boolean {\n    return !!this.#ignore?.childrenIgnored?.(path)\n  }\n\n  // backpressure mechanism\n  pause() {\n    this.paused = true\n  }\n  resume() {\n    /* c8 ignore start */\n    if (this.signal?.aborted) return\n    /* c8 ignore stop */\n    this.paused = false\n    let fn: (() => any) | undefined = undefined\n    while (!this.paused && (fn = this.#onResume.shift())) {\n      fn()\n    }\n  }\n  onResume(fn: () => any) {\n    if (this.signal?.aborted) return\n    /* c8 ignore start */\n    if (!this.paused) {\n      fn()\n    } else {\n      /* c8 ignore stop */\n      this.#onResume.push(fn)\n    }\n  }\n\n  // do the requisite realpath/stat checking, and return the path\n  // to add or undefined to filter it out.\n  async matchCheck(e: Path, ifDir: boolean): Promise<Path | undefined> {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || (await e.realpath())\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    return this.matchCheckTest(needStat ? await e.lstat() : e, ifDir)\n  }\n\n  matchCheckTest(e: Path | undefined, ifDir: boolean): Path | undefined {\n    return e &&\n      (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n      (!ifDir || e.canReaddir()) &&\n      (!this.opts.nodir || !e.isDirectory()) &&\n      !this.#ignored(e)\n      ? e\n      : undefined\n  }\n\n  matchCheckSync(e: Path, ifDir: boolean): Path | undefined {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || e.realpathSync()\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir)\n  }\n\n  abstract matchEmit(p: Result<O>): void\n  abstract matchEmit(p: string | Path): void\n\n  matchFinish(e: Path, absolute: boolean) {\n    if (this.#ignored(e)) return\n    const abs =\n      this.opts.absolute === undefined ? absolute : this.opts.absolute\n    this.seen.add(e)\n    const mark = this.opts.mark && e.isDirectory() ? this.#sep : ''\n    // ok, we have what we need!\n    if (this.opts.withFileTypes) {\n      this.matchEmit(e)\n    } else if (abs) {\n      const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath()\n      this.matchEmit(abs + mark)\n    } else {\n      const rel = this.opts.posix ? e.relativePosix() : e.relative()\n      const pre =\n        this.opts.dotRelative && !rel.startsWith('..' + this.#sep)\n          ? '.' + this.#sep\n          : ''\n      this.matchEmit(!rel ? '.' + mark : pre + rel + mark)\n    }\n  }\n\n  async match(e: Path, absolute: boolean, ifDir: boolean): Promise<void> {\n    const p = await this.matchCheck(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  matchSync(e: Path, absolute: boolean, ifDir: boolean): void {\n    const p = this.matchCheckSync(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  walkCB(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() => this.walkCB2(target, patterns, processor, cb))\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const childrenCached = t.readdirCached()\n      if (t.calledReaddir())\n        this.walkCB3(t, childrenCached, processor, next)\n      else {\n        t.readdirCB(\n          (_, entries) => this.walkCB3(t, entries, processor, next),\n          true\n        )\n      }\n    }\n\n    next()\n  }\n\n  walkCB3(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n\n  walkCBSync(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2Sync(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() =>\n        this.walkCB2Sync(target, patterns, processor, cb)\n      )\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const children = t.readdirSync()\n      this.walkCB3Sync(t, children, processor, next)\n    }\n\n    next()\n  }\n\n  walkCB3Sync(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2Sync(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n}\n\nexport class GlobWalker<\n  O extends GlobWalkerOpts = GlobWalkerOpts\n> extends GlobUtil<O> {\n  matches: O extends GWOFileTypesTrue\n    ? Set<Path>\n    : O extends GWOFileTypesFalse\n    ? Set<string>\n    : O extends GWOFileTypesUnset\n    ? Set<string>\n    : Set<Path | string>\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n    this.matches = new Set() as Matches<O>\n  }\n\n  matchEmit(e: Result<O>): void\n  matchEmit(e: Path | string): void {\n    this.matches.add(e)\n  }\n\n  async walk(): Promise<Matches<O>> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      await this.path.lstat()\n    }\n    await new Promise((res, rej) => {\n      this.walkCB(this.path, this.patterns, () => {\n        if (this.signal?.aborted) {\n          rej(this.signal.reason)\n        } else {\n          res(this.matches)\n        }\n      })\n    })\n    return this.matches\n  }\n\n  walkSync(): Matches<O> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    // nothing for the callback to do, because this never pauses\n    this.walkCBSync(this.path, this.patterns, () => {\n      if (this.signal?.aborted) throw this.signal.reason\n    })\n    return this.matches\n  }\n}\n\nexport class GlobStream<\n  O extends GlobWalkerOpts = GlobWalkerOpts\n> extends GlobUtil<O> {\n  results: O extends GWOFileTypesTrue\n    ? Minipass<Path, Path>\n    : O extends GWOFileTypesFalse\n    ? Minipass<string, string>\n    : O extends GWOFileTypesUnset\n    ? Minipass<string, string>\n    : Minipass<Path | string, Path | string>\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n    this.results = new Minipass({\n      signal: this.signal,\n      objectMode: true,\n    }) as MatchStream<O>\n    this.results.on('drain', () => this.resume())\n    this.results.on('resume', () => this.resume())\n  }\n\n  matchEmit(e: Result<O>): void\n  matchEmit(e: Path | string): void {\n    this.results.write(e)\n    if (!this.results.flowing) this.pause()\n  }\n\n  stream(): MatchStream<O> {\n    const target = this.path\n    if (target.isUnknown()) {\n      target.lstat().then(() => {\n        this.walkCB(target, this.patterns, () => this.results.end())\n      })\n    } else {\n      this.walkCB(target, this.patterns, () => this.results.end())\n    }\n    return this.results\n  }\n\n  streamSync(): MatchStream<O> {\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    this.walkCBSync(this.path, this.patterns, () => this.results.end())\n    return this.results\n  }\n}\n","import { Minimatch } from 'minimatch'\nimport { GlobOptions } from './glob.js'\n\n/**\n * Return true if the patterns provided contain any magic glob characters,\n * given the options provided.\n *\n * Brace expansion is not considered \"magic\" unless the `magicalBraces` option\n * is set, as brace expansion just turns one string into an array of strings.\n * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and\n * `'xby'` both do not contain any magic glob characters, and it's treated the\n * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`\n * is in the options, brace expansion _is_ treated as a pattern having magic.\n */\nexport const hasMagic = (\n  pattern: string | string[],\n  options: GlobOptions = {}\n): boolean => {\n  if (!Array.isArray(pattern)) {\n    pattern = [pattern]\n  }\n  for (const p of pattern) {\n    if (new Minimatch(p, options).hasMagic()) return true\n  }\n  return false\n}\n","import { escape, unescape } from 'minimatch'\nimport { Minipass } from 'minipass'\nimport { Path } from 'path-scurry'\nimport type {\n  GlobOptions,\n  GlobOptionsWithFileTypesFalse,\n  GlobOptionsWithFileTypesTrue,\n  GlobOptionsWithFileTypesUnset,\n} from './glob.js'\nimport { Glob } from './glob.js'\nimport { hasMagic } from './has-magic.js'\n\n/**\n * Syncronous form of {@link globStream}. Will read all the matches as fast as\n * you consume them, even all in a single tick if you consume them immediately,\n * but will still respond to backpressure if they're not consumed immediately.\n */\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Minipass<Path, Path>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesUnset\n): Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptions\n): Minipass<Path, Path> | Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).streamSync()\n}\n\n/**\n * Return a stream that emits all the strings or `Path` objects and\n * then emits `end` when completed.\n */\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Minipass<Path, Path>\nexport function globStream(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptions\n): Minipass<Path, Path> | Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).stream()\n}\n\n/**\n * Synchronous form of {@link glob}\n */\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Path[]\nexport function globSync(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptions\n): Path[] | string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).walkSync()\n}\n\n/**\n * Perform an asynchronous glob search for the pattern(s) specified. Returns\n * [Path](https://isaacs.github.io/path-scurry/classes/PathBase) objects if the\n * {@link withFileTypes} option is set to `true`. See {@link GlobOptions} for\n * full option descriptions.\n */\nasync function glob_(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): Promise<string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Promise<Path[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): Promise<string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptions\n): Promise<Path[] | string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).walk()\n}\n\n/**\n * Return a sync iterator for walking glob pattern matches.\n */\nexport function globIterateSync(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): Generator<Path, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptions\n): Generator<Path, void, void> | Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).iterateSync()\n}\n\n/**\n * Return an async iterator for walking glob pattern matches.\n */\nexport function globIterate(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined\n): AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue\n): AsyncGenerator<Path, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse\n): AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptions\n): AsyncGenerator<Path, void, void> | AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptions = {}\n) {\n  return new Glob(pattern, options).iterate()\n}\n\n// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc\nexport const streamSync = globStreamSync\nexport const stream = Object.assign(globStream, { sync: globStreamSync })\nexport const iterateSync = globIterateSync\nexport const iterate = Object.assign(globIterate, {\n  sync: globIterateSync,\n})\nexport const sync = Object.assign(globSync, {\n  stream: globStreamSync,\n  iterate: globIterateSync,\n})\n\n/* c8 ignore start */\nexport { escape, unescape } from 'minimatch'\nexport { Glob } from './glob.js'\nexport type {\n  GlobOptions,\n  GlobOptionsWithFileTypesFalse,\n  GlobOptionsWithFileTypesTrue,\n  GlobOptionsWithFileTypesUnset,\n} from './glob.js'\nexport { hasMagic } from './has-magic.js'\nexport type { IgnoreLike } from './ignore.js'\nexport type { MatchStream } from './walker.js'\nexport type {\n  Path,\n  WalkOptionsWithFileTypesTrue,\n  WalkOptionsWithFileTypesUnset,\n  WalkOptions,\n  FSOption,\n} from 'path-scurry'\n\n/* c8 ignore stop */\n\nexport const glob = Object.assign(glob_, {\n  glob: glob_,\n  globSync,\n  sync,\n  globStream,\n  stream,\n  globStreamSync,\n  streamSync,\n  globIterate,\n  iterate,\n  globIterateSync,\n  iterateSync,\n  Glob,\n  hasMagic,\n  escape,\n  unescape,\n})\nglob.glob = glob\n","import { createUnplugin } from 'unplugin';\nimport dedent from 'ts-dedent';\nimport { logger } from '@storybook/node-logger';\nimport { extractComponentsFromTemplate } from './extractComponentsFromTemplate';\nimport { TwigComponentConfiguration } from './symfony';\nimport { TwigComponentResolver } from './TwigComponentResolver';\nimport crypto from 'crypto';\n\nconst PLUGIN_NAME = 'twig-loader';\n\nexport type Options = {\n    twigComponentConfiguration: TwigComponentConfiguration;\n};\n\n/**\n * Twig template source loader.\n *\n * Generates JS modules to export raw template source and imports required components.\n */\nexport const TwigLoaderPlugin = createUnplugin<Options>((options) => {\n    const { twigComponentConfiguration } = options;\n    const resolver = new TwigComponentResolver(twigComponentConfiguration);\n    return {\n        name: PLUGIN_NAME,\n        enforce: 'pre',\n        transformInclude: (id) => {\n            return /\\.html\\.twig$/.test(id);\n        },\n        transform: async (code, id) => {\n            const imports: string[] = [];\n\n            try {\n                const components = new Set<string>(extractComponentsFromTemplate(code));\n\n                components.forEach((name) => {\n                    imports.push(resolver.resolveFileFromName(name));\n                });\n            } catch (err) {\n                logger.warn(dedent`\n                Failed to parse template in '${id}': ${err}\n                `);\n            }\n\n            const name = resolver.resolveNameFromFile(id);\n\n            return dedent`\n            ${imports.map((file) => `import '${file}';`).join('\\n')}            \n            export default { \n                name: \\'${name}\\',\n                hash: \\`${crypto.createHash('sha1').update(code).digest('hex')}\\`,\n            }; \n           `;\n        },\n    };\n});\n","import { XMLParser } from 'fast-xml-parser';\n\nexport const extractComponentsFromTemplate = (source: string) => {\n    const reservedNames = ['block'];\n    const tagRe = new RegExp(/twig:[A-Za-z]+(?::[A-Za-z]+)*/);\n    const functionRe = new RegExp(/component\\(\\s*'([A-Za-z]+(?::[A-Za-z]+)*)'\\s*(?:,.*)?\\)/, 'gs');\n\n    const lookupComponents = (obj: { [p: string]: any }): string[] => {\n        return Object.entries(obj).reduce((names, [key, value]) => {\n            if (value !== null && typeof value === 'object') {\n                names.push(...lookupComponents(value));\n            } else if (typeof value === 'string') {\n                for (const m of value.matchAll(functionRe)) {\n                    names.push([...m][1]);\n                }\n            }\n            if (tagRe.test(key)) {\n                names.push(key.replace('twig:', ''));\n            }\n            return names;\n        }, [] as string[]);\n    };\n\n    try {\n        // Dummy div tag to handle templates without any tag\n        const documentObj = new XMLParser().parse(`<div>${source}</div>`);\n\n        return lookupComponents(documentObj).filter((name) => !reservedNames.includes(name));\n    } catch (err) {\n        throw new Error('Invalid XML.', {\n            cause: {\n                parserError: err,\n                template: source,\n            },\n        });\n    }\n};\n","import { TwigComponentConfiguration } from './symfony';\nimport path from 'path';\nimport dedent from 'ts-dedent';\n\nexport class TwigComponentResolver {\n    constructor(private config: TwigComponentConfiguration) {}\n\n    resolveNameFromFile(file: string) {\n        const stripDirectory = (file: string, dir: string) => {\n            return file.replace(dir, '').replace(/^\\//, '').replaceAll('/', ':').replace('.html.twig', '');\n        };\n\n        for (const namespace in this.config.namespaces) {\n            const dir = this.config.namespaces[namespace];\n            if (0 === file.indexOf(dir)) {\n                const trimmed = stripDirectory(file, dir);\n                if ('' !== namespace) {\n                    return `${namespace}:${trimmed}`;\n                }\n                return trimmed;\n            }\n        }\n\n        if (0 === file.indexOf(this.config.anonymousTemplateDirectory)) {\n            return stripDirectory(file, this.config.anonymousTemplateDirectory);\n        }\n\n        throw new Error(dedent`Unable to determine template name for file \"${file}\":`);\n    }\n\n    resolveFileFromName(name: string) {\n        const nameParts = name.split(':');\n        const dirParts = nameParts.slice(0, -1);\n        const filename = `${nameParts.slice(-1)}.html.twig`;\n\n        const lookupPaths: string[] = [];\n\n        for (const namespace in this.config.namespaces) {\n            if ('' !== namespace && 0 === name.indexOf(namespace)) {\n                lookupPaths.push(path.join(this.config.namespaces[namespace], dirParts.slice(1).join('/')));\n                break;\n            }\n        }\n\n        if (this.config.namespaces[''] !== undefined) {\n            lookupPaths.push(path.join(this.config.namespaces[''], dirParts.join('/')));\n        }\n\n        lookupPaths.push(path.join(this.config.anonymousTemplateDirectory, dirParts.join('/')));\n\n        try {\n            return require.resolve(`./${filename}`, { paths: lookupPaths });\n        } catch (err) {\n            throw new Error(dedent`Unable to find template file for component \"${name}\": ${err}`);\n        }\n    }\n}\n"]}