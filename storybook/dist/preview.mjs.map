{"version":3,"sources":["../src/addons/actions.ts","../src/preview.ts"],"names":["useEffect","ACTION_ATTRIBUTE","isActionArg","arg","generateActionId","proxifyEvent","e","elementProxy","target","key","obj","popActionArgs","args","actions","argName","actionId","cleanedArgs","setupActions","StoryFn","context","root","listeners","acc","action","el","fetchStoryHtml","url","path","params","storyContext","fetchUrl","decorators","server"],"mappings":"AAEA,OAAS,aAAAA,MAAiB,yBAU1B,IAAMC,EAAmB,wBACnBC,EAAeC,GACVA,GAAK,OAAS,UAGnBC,EAAmB,IAAc,CACnC,GAAI,CAAC,OAAO,OACR,MAAM,IAAI,MAAM,qDAAqD,EAGzE,OAAO,OAAO,OAAO,WAAW,CACpC,EAEMC,EAAiCC,GAAS,CAC5C,GAAIA,EAAE,gBAAkB,MAAQ,OAAO,OAAOA,EAAE,cAAe,aAAa,EAAG,CAI3E,IAAMC,EAAe,IAAI,MAAMD,EAAE,cAAe,CAC5C,QAAQE,EAA6C,CACjD,OAAO,OAAO,KAAKA,CAAM,EAAE,OAAQC,GAAQA,IAAQ,aAAa,CACpE,CACJ,CAAC,EACD,OAAO,IAAI,MAAMH,EAAG,CAChB,IAAII,EAAKD,EAAK,CACV,OAAIA,IAAQ,gBACDF,EAEJ,QAAQ,IAAIG,EAAKD,CAAG,CAC/B,CACJ,CAAC,CACL,CAEA,OAAOH,CACX,EAEMK,EAAiBC,GAAe,CAClC,IAAMC,EAAuB,CAAC,EAE9B,QAAWC,KAAWF,EAAM,CACxB,IAAMT,EAAMS,EAAKE,CAAO,EACxB,GAAIZ,EAAYC,CAAG,EAAG,CAClB,IAAMY,EAAWX,EAAiB,EAClCS,EAAQ,KAAK,CACT,MAAOC,EACP,QAAS,IAAIF,IAAS,CAClB,IAAMI,EAAcJ,EAAK,IAAIP,CAAY,EAEzCF,EAAI,GAAGa,CAAW,CACtB,EACA,GAAID,CACR,CAAC,EACDH,EAAKE,CAAO,EAAIC,CACpB,CACJ,CAEA,OAAOF,CACX,EAEaI,EAAkD,CAACC,EAASC,IAAY,CACjF,GAAM,CAAE,KAAAP,CAAK,EAAIO,EAEXN,EAAUF,EAAcC,CAAI,EAE5BQ,EAAO,SAAS,eAAe,gBAAgB,EACrD,OAAApB,EAAU,IAAM,CACZ,GAAaoB,IAAT,KACA,OAGJ,IAAMC,EAAYR,EAAQ,OACtB,CAACS,EAAKC,IAAW,CACb,IAAMC,EAAKJ,EAAK,cAAc,IAAInB,CAAgB,KAAKsB,EAAO,EAAE,IAAI,EACpE,OAAaC,IAAT,MACAF,EAAI,KAAK,CAAE,GAAIE,EAAI,OAAQD,CAAO,CAAC,EAEhCD,CACX,EACA,CAAC,CACL,EAEA,OAAAD,EAAU,QAAQ,CAAC,CAAE,GAAAG,EAAI,OAAAD,CAAO,IAAMC,EAAG,iBAAiBD,EAAO,MAAOA,EAAO,OAAO,CAAC,EAEhF,IAAMF,EAAU,QAAQ,CAAC,CAAE,GAAAG,EAAI,OAAAD,CAAO,IAAMC,EAAG,oBAAoBD,EAAO,MAAOA,EAAO,OAAO,CAAC,CAC3G,EAAG,CAACH,EAAMP,CAAO,CAAC,EAEXK,EAAQC,CAAO,CAC1B,ECzFA,IAAMM,EAAiB,MAAOC,EAAaC,EAAcC,EAAaC,IAAqC,CACvG,IAAMC,EAAW,IAAI,IAAI,GAAGJ,CAAG,IAAIC,CAAI,EAAE,EAEzC,OAAAG,EAAS,OAAS,IAAI,gBAAgB,CAAE,GAAGD,EAAa,QAAS,GAAGD,CAAO,CAAC,EAAE,SAAS,GAEtE,MAAM,MAAME,CAAQ,GAErB,KAAK,CACzB,EAKaC,EAAa,CACtB,CAACb,EAAwCC,IAA0C,CAC/E,GAAM,CAAE,OAAAa,EAAS,CAAC,CAAE,EAAIb,EAAQ,WAEhC,OAAIa,EAAO,MAAQ,SACfA,EAAO,IAAM,GAAG,OAAO,SAAS,MAAM,sBAG1CA,EAAO,eAAiBP,EAExBN,EAAQ,WAAW,OAASa,EAErBd,EAAQ,CACnB,EACAD,CACJ","sourcesContent":["import { Args, DecoratorFunction } from '@storybook/types';\nimport { ServerRenderer } from '@storybook/server';\nimport { useEffect } from '@storybook/preview-api';\n\ntype ActionHandler = (...args: any[]) => void;\n\ntype ActionArg = {\n    event: string;\n    handler: ActionHandler;\n    id: string;\n};\n\nconst ACTION_ATTRIBUTE = 'data-storybook-action';\nconst isActionArg = (arg: any) => {\n    return arg?.name === 'handler';\n};\n\nconst generateActionId = (): string => {\n    if (!window.crypto) {\n        throw new Error('The crypto module is not available in your browser.');\n    }\n\n    return window.crypto.randomUUID();\n};\n\nconst proxifyEvent = <T extends Event>(e: T) => {\n    if (e.currentTarget !== null && Object.hasOwn(e.currentTarget, '__component')) {\n        // Special handling for Live Components:\n        // creates a proxy wrapper to omit the __component property that could\n        // make actions calls when its properties are listed\n        const elementProxy = new Proxy(e.currentTarget, {\n            ownKeys(target: Element): ArrayLike<string | symbol> {\n                return Object.keys(target).filter((key) => key !== '__component');\n            },\n        });\n        return new Proxy(e, {\n            get(obj, key) {\n                if (key === 'currentTarget') {\n                    return elementProxy;\n                }\n                return Reflect.get(obj, key);\n            },\n        });\n    }\n\n    return e;\n};\n\nconst popActionArgs = (args: Args) => {\n    const actions: ActionArg[] = [];\n\n    for (const argName in args) {\n        const arg = args[argName];\n        if (isActionArg(arg)) {\n            const actionId = generateActionId();\n            actions.push({\n                event: argName,\n                handler: (...args) => {\n                    const cleanedArgs = args.map(proxifyEvent);\n\n                    arg(...cleanedArgs);\n                },\n                id: actionId,\n            });\n            args[argName] = actionId;\n        }\n    }\n\n    return actions;\n};\n\nexport const setupActions: DecoratorFunction<ServerRenderer> = (StoryFn, context) => {\n    const { args } = context;\n\n    const actions = popActionArgs(args);\n\n    const root = document.getElementById('storybook-root');\n    useEffect(() => {\n        if (null === root) {\n            return;\n        }\n\n        const listeners = actions.reduce(\n            (acc, action) => {\n                const el = root.querySelector(`[${ACTION_ATTRIBUTE}='${action.id}']`);\n                if (null !== el) {\n                    acc.push({ el: el, action: action });\n                }\n                return acc;\n            },\n            [] as { el: Element; action: ActionArg }[]\n        );\n\n        listeners.forEach(({ el, action }) => el.addEventListener(action.event, action.handler));\n\n        return () => listeners.forEach(({ el, action }) => el.removeEventListener(action.event, action.handler));\n    }, [root, actions]);\n\n    return StoryFn(context);\n};\n","import { Args, PartialStoryFn as StoryFunction } from '@storybook/types';\nimport { ServerRenderer, StoryContext} from '@storybook/server';\nimport { setupActions } from './addons/actions';\n\n\n/**\n * Copy/pasted from storybook/renderers/server/src/render.ts.\n *\n * So we can wrap the output in decorators.\n */\nconst fetchStoryHtml = async (url: string, path: string, params: any, storyContext: StoryContext<Args>) => {\n    const fetchUrl = new URL(`${url}/${path}`);\n\n    fetchUrl.search = new URLSearchParams({ ...storyContext.globals, ...params }).toString();\n\n    const response = await fetch(fetchUrl);\n\n    return response.text();\n};\n\n/**\n * Decorator to set server URL\n */\nexport const decorators = [\n    (StoryFn: StoryFunction<ServerRenderer>, context: StoryContext<ServerRenderer>) => {\n        const { server = {} } = context.parameters;\n\n        if (server.url === undefined) {\n            server.url = `${window.location.origin}/_storybook/render`;\n        }\n\n        server.fetchStoryHtml = fetchStoryHtml;\n\n        context.parameters.server = server;\n\n        return StoryFn();\n    },\n    setupActions\n];\n"]}